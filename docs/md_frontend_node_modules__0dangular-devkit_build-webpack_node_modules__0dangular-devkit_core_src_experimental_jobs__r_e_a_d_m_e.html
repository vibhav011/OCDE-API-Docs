<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OCDE: Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OCDE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_frontend_node_modules__0dangular-devkit_build-webpack_node_modules__0dangular-devkit_core_src_experimental_jobs__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Jobs is the Angular DevKit subsystem for scheduling and running generic functions with clearly typed inputs and outputs. A <code>Job</code> instance is a function associated with metadata. You can schedule a job, synchronize it with other jobs, and use it to schedule other jobs.</p>
<p>The whole API is serializable, allowing you to use a Node Stream or message channel to communicate between the job and the job scheduler.</p>
<p>Jobs are lazy, cold, and guaranteed to execute exactly once when scheduled. Subscribing to a job returns messages from the point where the job is at.</p>
<h1><a class="anchor" id="autotoc_md951"></a>
Argument, Input, Output and Channels</h1>
<p>A job receives a single argument when scheduled and can also listen to an input channel. It can emit multiple outputs, and can also provide multiple output channels that emit asynchronous JSON messages, which can be typed.</p>
<p>The I/O model is like that of an executable, where the argument corresponds to arguments on the command line, the input channel to STDIN, the output channel to STDOUT, and the channels would be additional output streams.</p>
<h1><a class="anchor" id="autotoc_md952"></a>
LifeCycle</h1>
<p>A <code>Job</code> goes through multiple LifeCycle messages before its completion;</p><ol type="1">
<li><code>JobState.Queued</code>. The job was queued and is waiting. This is the default state from the scheduler.</li>
</ol>
<ol type="1">
<li><code>JobState.Ready</code>. The job's dependencies (see <a href="#Dependencies">"Synchronizing and Dependencies"</a>) are done running, the argument is validated, and the job is ready to execute.</li>
</ol>
<ol type="1">
<li><code>JobState.Started</code>. The argument has been validated, the job has been called and is running. This is handled by the job itself (or <code>createJobHandler()</code>).</li>
</ol>
<ol type="1">
<li><code>JobState.Ended</code>. The job has ended and is done running. This is handled by the job itself (or <code>createJobHandler()</code>).</li>
</ol>
<ol type="1">
<li><code>JobState.Errored</code>. A unrecoverable error happened.</li>
</ol>
<p>Each state (except <code>Queued</code>) corresponds to a <code>JobOutboundMessage</code> on the <code>outboundBus</code> observable that triggers the state change. The <code>Scheduler</code> emits the <code>Ready</code> and <code>Errored</code> messages; the job implementation should not emit them, and if it does they are filtered out. You can listen for these messages or use the corresponding state member.</p>
<p>The job implementation should emit the <code>Start</code> and <code>End</code> messages when it is starting the job logic itself. Only the first <code>Start</code> and <code>End</code> messages will be forwarded. Any more will be filtered out.</p>
<p>The <code>Queued</code> state is set as the job is scheduled, so there is no need to listen for the message.</p>
<h1><a class="anchor" id="autotoc_md953"></a>
&lt;tt&gt;Job&lt;OutputType&gt;&lt;/tt&gt; Object</h1>
<p>The <code>Job</code> object that is returned when you schedule a job provides access to the job's status and utilities for tracking and modifying the job.</p>
<ol type="1">
<li><code>id</code>. A unique symbol that can be used as a Map key.</li>
</ol>
<ol type="1">
<li><code>description</code>. The description of the job from the scheduler. See <code>JobDescription</code> object.</li>
</ol>
<ol type="1">
<li><code>argument</code>. The argument value that was used to start the job.</li>
</ol>
<ol type="1">
<li><code>input</code>. An <code>Observer</code> that can be used to send validated inputs to the job itself.</li>
</ol>
<ol type="1">
<li><code>output</code>. An <code>Observable&lt;OutputType&gt;</code> that filters out messages to get only the returned output of a job.</li>
</ol>
<ol type="1">
<li><code>promise</code>. A promise that waits for the last output of a job. Returns the last value outputted (or no value if there's no last value).</li>
</ol>
<ol type="1">
<li><code>state</code>. The current state of the job (see <code>LifeCycle</code>).</li>
</ol>
<ol type="1">
<li><code>channels</code>. A map of side channels the user can listen to as <code>Observable</code>.</li>
</ol>
<ol type="1">
<li><code>ping()</code>. A function that can be used to ping the job, receiving a <code>Promise</code> for when the ping is answered.</li>
</ol>
<ol type="1">
<li><code>stop()</code>. Sends a <code>stop</code> input to the job, which suggests to stop the job. The job itself can choose to ignore this message.</li>
</ol>
<ol type="1">
<li><code>inboundBus</code>. The raw input <code>Observer&lt;JobInboundMessage&gt;</code>. This can be used to send messages to the <code>context.inboundBus</code> observable in the job. These are <code>JobInboundMessage</code> messages. See <a href="#Communicating">"Communicating With Jobs"</a>.</li>
</ol>
<ol type="1">
<li><code>outboundBus</code>. The raw output <code>Observable&lt;JobOutput&gt;</code>. This can be used to listen to messages from the job. See <a href="#Communicating">"Communicating With Jobs"</a>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md954"></a>
&lt;tt&gt;JobHandlerContext&lt;I, O&gt;&lt;/tt&gt; Object</h1>
<p>The <code>JobHandlerContext&lt;&gt;</code> is passed to the job handler code in addition to its argument. The context contains the following members:</p>
<ol type="1">
<li><code>description</code>. The description of the job. Its name and schemas.</li>
</ol>
<ol type="1">
<li><code>scheduler</code>. A <code>Scheduler&lt;&gt;</code> instance that can be used to create additional jobs.</li>
</ol>
<ol type="1">
<li><code>dependencies</code>. A generic list of other job instances that were run as dependencies when scheduling this job. Their <code>id</code> is not guaranteed to match the <code>id</code> of the <code>Job&lt;&gt;</code> instance itself (those <code>Job&lt;&gt;</code>s might just be proxies). The state of those <code>Job&lt;&gt;</code> is guaranteed to be <code>JobState.Ended</code>, as <code>JobState.Errored</code> would have prevented this handler from running.</li>
</ol>
<ol type="1">
<li><code>inboundBus</code>. The raw input observable, complement of the <code>inboundBus</code> observer from the <code>Job&lt;&gt;</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md955"></a>
Examples</h1>
<p>An example of a job that adds all input together and return the output value. We use a simple synchronous job registry and a simple job scheduler.</p>
<div class="fragment"><div class="line">import { jobs } from &#39;@angular-devkit/core&#39;;</div>
<div class="line"> </div>
<div class="line">const add = jobs.createJobHandle&lt;number[], number&gt;(</div>
<div class="line">  input =&gt; input.reduce((total, curr) =&gt; total + curr, 0),</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">// Register the job in a SimpleJobRegistry. Different registries have different API.</div>
<div class="line">const registry = new jobs.SimpleJobRegistry();</div>
<div class="line">const scheduler = new jobs.SimpleScheduler(registry);</div>
<div class="line">registry.register(add, {</div>
<div class="line">  name: &#39;add&#39;,</div>
<div class="line">  input: { type: &#39;array&#39;, items: { type: &#39;number&#39; } },</div>
<div class="line">  output: { type: &#39;number&#39; },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">scheduler.schedule(&#39;add&#39;, [1, 2, 3, 4]).promise</div>
<div class="line">  .then(output =&gt; console.log(&#39;1 + 2 + 3 + 4 is &#39; + output));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md956"></a>
Creating Jobs</h1>
<p>A job is at its core a function with a description object attached to it. The description object stores the JSON schemas used to validate the types of the argument passed in, the input and output values. By default, a job accepts and can output any JSON object.</p>
<div class="fragment"><div class="line">import { Observable } from &#39;rxjs&#39;;</div>
<div class="line">import { jobs } from &#39;@angular-devkit/core&#39;;</div>
<div class="line"> </div>
<div class="line">const argument = {</div>
<div class="line">  type: &#39;array&#39;, items: { type: &#39;number&#39; },</div>
<div class="line">};</div>
<div class="line">const output = {</div>
<div class="line">  type: &#39;number&#39;,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">export function add(argument: number[]): Observable&lt;jobs.JobOutboundMessage&lt;number&gt;&gt; {</div>
<div class="line">  return new Observable(o =&gt; {</div>
<div class="line">    o.next({ kind: jobs.JobOutboundMessageKind.Start });</div>
<div class="line">    o.next({</div>
<div class="line">      kind: jobs.JobOutboundMessageKind.Output,</div>
<div class="line">      output: argument.reduce((total, curr) =&gt; total + curr, 0),</div>
<div class="line">    });</div>
<div class="line">    o.next({ kind: jobs.JobOutboundMessageKind.End });</div>
<div class="line">    o.complete();</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Add a property to `add` to make it officially a JobHandler. The Job system does not recognize</div>
<div class="line">// any function as a JobHandler.</div>
<div class="line">add.jobDescription = {</div>
<div class="line">  argument: argument,</div>
<div class="line">  output: output,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Call the job with an array as argument, and log its output.</div>
<div class="line">declare const scheduler: jobs.Scheduler;</div>
<div class="line">scheduler.schedule(&#39;add&#39;, [1, 2, 3, 4])</div>
<div class="line">    .output.subscribe(x =&gt; console.log(x));  // Will output 10.</div>
</div><!-- fragment --><p>This is a lot of boilerplate, so we made some helpers to improve readability and manage argument, input and output automatically:</p>
<div class="fragment"><div class="line">// Add is a JobHandler function, like the above.</div>
<div class="line">export const add = jobs.createJobHandler&lt;number[], number&gt;(</div>
<div class="line">  argument =&gt; argument.reduce((total, curr) =&gt; total + curr, 0),</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">// Schedule like above.</div>
</div><!-- fragment --><p>You can also return a Promise or an Observable, as jobs are asynchronous. This helper will set start and end messages appropriately. It will also manage channels automatically (see below).</p>
<p>A more complex job can be declared like this:</p>
<div class="fragment"><div class="line">import { Observable } from &#39;rxjs&#39;;</div>
<div class="line">import { jobs } from &#39;@angular-devkit/core&#39;;</div>
<div class="line"> </div>
<div class="line">// Show progress with each count in a separate output channel. Output &quot;more&quot; in a channel.</div>
<div class="line">export const count = jobs.createJobHandler&lt;number, number&gt;(</div>
<div class="line">  // Receive a context that contains additional methods to create channels.</div>
<div class="line">  (argument: number, { createChannel }) =&gt; new Observable&lt;number&gt;(o =&gt; {</div>
<div class="line">    const side = createChannel(&#39;side&#39;, { type: &#39;string&#39;, const: &#39;more&#39; });</div>
<div class="line">    const progress = createChannel(&#39;progress&#39;, { type: &#39;number&#39; });</div>
<div class="line">    let i = 0;</div>
<div class="line">    function doCount() {</div>
<div class="line">      o.next(i++);</div>
<div class="line">      progress.next(i / argument);</div>
<div class="line">      side.next(&#39;more&#39;);</div>
<div class="line">  </div>
<div class="line">      if (i &lt; argument) {</div>
<div class="line">        setTimeout(doCount, 100);</div>
<div class="line">      } else {</div>
<div class="line">        o.complete();</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    setTimeout(doCount, 100);</div>
<div class="line">  }),</div>
<div class="line">  {</div>
<div class="line">    argument: { type: &#39;number&#39; },</div>
<div class="line">    output: { type: &#39;number&#39; },</div>
<div class="line">  },</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">// Get a hold of a scheduler that refers to the job above.</div>
<div class="line">declare const scheduler: jobs.Scheduler;</div>
<div class="line"> </div>
<div class="line">const job = scheduler.schedule(&#39;count&#39;, 0);</div>
<div class="line">job.getChannel(&#39;side&#39;).subscribe(x =&gt; console.log(x));</div>
<div class="line">// You can type a channel too. Messages will be filtered out.</div>
<div class="line">job.getChannel&lt;number&gt;(&#39;progress&#39;, { type: &#39;number&#39; }).subscribe(x =&gt; console.log(x));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md957"></a>
&lt;a name="Communicating"&gt;&lt;/a&gt;Communicating With Jobs</h2>
<p>Jobs can be started and updated in a separate process or thread, and as such communication with a job should avoid using global objects (which might not be shared). The jobs API and schedulers provide 2 communication streams (one for input and the other for output), named <code>inboundBus</code> and <code>outboundBus</code>.</p>
<h3><a class="anchor" id="autotoc_md958"></a>
Raw Input Stream</h3>
<p>The <code>schedule()</code> function returns a <code>Job&lt;&gt;</code> interface that contains a <code>inboundBus</code> member of type <code>Observer&lt;JobInboundMessage&gt;</code>. All messages sent <em>to</em> the job goes through this stream. The <code>kind</code> member of the <code>JobInboundMessage</code> interface dictates what kind of message it is sending:</p>
<ol type="1">
<li><code>JobInboundMessageKind.Ping</code>. A simple message that should be answered with <code>JobOutboundMessageKind.Pong</code> when the job is responsive. The <code>id</code> field of the message should be used when returning <code>Pong</code>.</li>
</ol>
<ol type="1">
<li><code>JobInboundMessageKind.Stop</code>. The job should be stopped. This is used when cancelling/unsubscribing from the <code>output</code> (or by calling <code>stop()</code>). Any inputs or outputs after this message will be ignored.</li>
</ol>
<ol type="1">
<li><code>JobInboundMessageKind.Input</code> is used when sending inputs to a job. These correspond to the <code>next</code> methods of an <code>Observer</code> and are reported to the job through its <code>context.input</code> Observable. There is no way to communicate an error to the job.</li>
</ol>
<p>Using the <code>createJobHandler()</code> helper, all those messages are automatically handled by the boilerplate code. If you need direct access to raw inputs, you should subscribe to the <code>context.inboundBus</code> Observable.</p>
<h3><a class="anchor" id="autotoc_md959"></a>
Raw Output Stream</h3>
<p>The <code>Job&lt;&gt;</code> interface also contains a <code>outboundBus</code> member (of type <code>Observable&lt;JobOutboundMessage&lt;O&gt;&gt;</code> where <code>O</code> is the typed output of the job) which is the output complement of <code>inboundBus</code>. All messages sent <em>from</em> the job goes through this stream. The <code>kind</code> member of the <code>JobOutboundMessage&lt;O&gt;</code> interface dictates what kind of message it is sending:</p>
<ol type="1">
<li><code>JobOutboundMessageKind.Create</code>. The <code>Job&lt;&gt;</code> was created, its dependencies are done, and the library is validating Argument and calling the internal job code.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Start</code>. The job code itself should send that message when started. <code>createJobHandler()</code> will do it automatically.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.End</code>. The job has ended. This is done by the job itself and should always be sent when completed. The scheduler will listen to this message to set the state and unblock dependent jobs. <code>createJobHandler()</code> automatically send this message.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Pong</code>. The job should answer a <code>JobInboundMessageKind.Ping</code> message with this. Automatically done by <code>createJobHandler()</code>.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Output</code>. An <code>Output</code> has been generated by the job.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.ChannelMessage</code>, <code>JobOutboundMessageKind.ChannelError</code> and <code>JobOutboundMessageKind.ChannelComplete</code> are used for output channels. These correspond to the <code>next</code>, <code>error</code> and <code>complete</code> methods of an <code>Observer</code> and are available to the callee through the <code>job.channels</code> map of Observable.</li>
</ol>
<p>Those messages can be accessed directly through the <code>job.outboundBus</code> member. The job itself should return an <code>Observable&lt;JobOutboundMessage&lt;O&gt;&gt;</code>. The <code>createJobHandler()</code> helper handles most of use cases of this and makes it easier for jobs to handle this.</p>
<h2><a class="anchor" id="autotoc_md960"></a>
Job Dispatchers</h2>
<p>Dispatchers are a helper that redirect to different jobs given conditions. To create a job dispatcher, use the <code>createDispatcher()</code> function:</p>
<div class="fragment"><div class="line">import { jobs } from &#39;@angular-devkit/core&#39;;</div>
<div class="line"> </div>
<div class="line">// A dispatcher that installs node modules given a user&#39;s preference.</div>
<div class="line">const dispatcher = jobs.createDispatcher({</div>
<div class="line">  name: &#39;node-install&#39;,</div>
<div class="line">  argument: { properties: { moduleName: { type: &#39;string&#39; } } },</div>
<div class="line">  output: { type: &#39;boolean&#39; },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const npmInstall = jobs.createJobHandler(/* ... */, { name: &#39;npm-install&#39; });</div>
<div class="line">const yarnInstall = jobs.createJobHandler(/* ... */, { name: &#39;yarn-install&#39; });</div>
<div class="line">const pnpmInstall = jobs.createJobHandler(/* ... */, { name: &#39;pnpm-install&#39; });</div>
<div class="line"> </div>
<div class="line">declare const registry: jobs.SimpleJobRegistry;</div>
<div class="line">registry.register(dispatcher);</div>
<div class="line">registry.register(npmInstall);</div>
<div class="line">registry.register(yarnInstall);</div>
<div class="line">registry.register(pnpmInstall);</div>
<div class="line"> </div>
<div class="line">// Default to npm.</div>
<div class="line">dispatcher.setDefaultDelegate(npmInstall.name);</div>
<div class="line">// If the user is asking for yarn over npm, uses it.</div>
<div class="line">dispatcher.addConditionalDelegate(() =&gt; userWantsYarn, yarnInstall.name);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md961"></a>
Execution Strategy</h2>
<p>Jobs are always run in parallel and will always start, but many helper functions are provided when creating a job to help you control the execution strategy;</p>
<ol type="1">
<li><code>serialize()</code>. Multiple runs of this job will be queued with each others.</li>
</ol>
<ol type="1">
<li><code>memoize(replayMessages = false)</code> will create a job, or reuse the same job when inputs are matching. If the inputs don't match, a new job will be started and its outputs will be stored.</li>
</ol>
<p>These strategies can be used when creating the job:</p>
<div class="fragment"><div class="line">// Same input and output as above.</div>
<div class="line"> </div>
<div class="line">export const add = jobs.strategy.memoize()(</div>
<div class="line">  jobs.createJobHandler&lt;number[], number&gt;(</div>
<div class="line">      argument =&gt; argument.reduce((total, curr) =&gt; total + curr, 0),</div>
<div class="line">  ),</div>
<div class="line">);</div>
</div><!-- fragment --><p>Strategies can be reused to synchronize between jobs. For example, given jobs <code>jobA</code> and <code>jobB</code>, you can reuse the strategy to serialize both jobs together;</p>
<div class="fragment"><div class="line">const strategy = jobs.strategy.serialize();</div>
<div class="line">const jobA = strategy(jobs.createJobHandler(...));</div>
<div class="line">const jobB = strategy(jobs.createJobHandler(...));</div>
</div><!-- fragment --><p>Even further, we can have package A and package B run in serialization, and B and C also be serialized. Running A and C will run in parallel, while running B will wait for both A and C to finish.</p>
<div class="fragment"><div class="line">const strategy1 = jobs.strategy.serialize();</div>
<div class="line">const strategy2 = jobs.strategy.serialize();</div>
<div class="line">const jobA = strategy1(jobs.createJobHandler(...));</div>
<div class="line">const jobB = strategy1(strategy2(jobs.createJobHandler(...)));</div>
<div class="line">const jobC = strategy2(jobs.createJobHandler(...));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md962"></a>
Scheduling Jobs</h1>
<p>Jobs can be scheduled using a <code>Scheduler</code> interface, which contains a <code>schedule()</code> method:</p>
<div class="fragment"><div class="line">interface Scheduler {</div>
<div class="line">  /**</div>
<div class="line">   * Schedule a job to be run, using its name.</div>
<div class="line">   * @param name The name of job to be run.</div>
<div class="line">   * @param argument The argument to send to the job when starting it.</div>
<div class="line">   * @param options Scheduling options.</div>
<div class="line">   * @returns The Job being run.</div>
<div class="line">   */</div>
<div class="line">  schedule&lt;I extends MinimumInputValueT, O extends MinimumOutputValueT&gt;(</div>
<div class="line">    name: JobName,</div>
<div class="line">    argument: I,</div>
<div class="line">    options?: ScheduleJobOptions,</div>
<div class="line">  ): Job&lt;JsonValue, O&gt;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The scheduler also has a <code>getDescription()</code> method to get a <code>JobDescription</code> object for a certain name; that description contains schemas for the argument, input, output, and other channels:</p>
<div class="fragment"><div class="line">interface Scheduler {</div>
<div class="line">  /**</div>
<div class="line">   * Get a job description for a named job.</div>
<div class="line">   *</div>
<div class="line">   * @param name The name of the job.</div>
<div class="line">   * @returns A description, or null if the job cannot be scheduled.</div>
<div class="line">   */</div>
<div class="line">  getDescription(name: JobName): JobDescription | null;</div>
<div class="line">    </div>
<div class="line">  /**</div>
<div class="line">   * Returns true if the job name has been registered.</div>
<div class="line">   * @param name The name of the job.</div>
<div class="line">   * @returns True if the job exists, false otherwise.</div>
<div class="line">   */</div>
<div class="line">  has(name: JobName): boolean;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, the scheduler interface has a <code>pause()</code> method to stop scheduling. This will queue all jobs and wait for the unpause function to be called before unblocking all the jobs scheduled. This does not affect already running jobs.</p>
<div class="fragment"><div class="line">interface Scheduler {</div>
<div class="line">  /**</div>
<div class="line">   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be</div>
<div class="line">   * used to resume execution. If multiple `pause()` were called, all their resume functions must</div>
<div class="line">   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume</div>
<div class="line">   * function will have no effect.</div>
<div class="line">   *</div>
<div class="line">   * Jobs already running are NOT paused. This is pausing the scheduler only.</div>
<div class="line">   *</div>
<div class="line">   * @returns A function that can be run to resume the scheduler. If multiple `pause()` calls</div>
<div class="line">   *          were made, all their return function must be called (in any order) before the</div>
<div class="line">   *          scheduler can resume.</div>
<div class="line">   */</div>
<div class="line">  pause(): () =&gt; void;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md963"></a>
&lt;a name="Dependencies"&gt;&lt;/a&gt;Synchronizing and Dependencies</h2>
<p>When scheduling jobs, it is often necessary to run jobs after certain other jobs are finished. This is done through the <code>dependencies</code> options in the <code>schedule()</code> method.</p>
<p>These jobs will also be passed to the job being scheduled, through its context. This can be useful if, for example, the output of those jobs are of a known type, or have known side channels.</p>
<p>An example of this would be a compiler that needs to know the output directory of other compilers before it, in a tool chain.</p>
<h3><a class="anchor" id="autotoc_md964"></a>
Dependencies</h3>
<p>When scheduling jobs, the user can add a <code>dependencies</code> field to the scheduling options. The scheduler will wait for those dependencies to finish before running the job, and pass those jobs in the context of the job.</p>
<h3><a class="anchor" id="autotoc_md965"></a>
Accessing Dependencies</h3>
<p>Jobs are called with a <code>JobHandlerContext</code> as a second argument, which contains a <code>dependencies: Job&lt;JsonValue&gt;[]</code> member which contains all dependencies that were used when scheduling the job. Those aren't fully typed as they are determined by the user, and not the job itself. They also can contain jobs that are not finished, and the job should use the <code>state</code> member of the job itself before trying to access its content.</p>
<h3><a class="anchor" id="autotoc_md966"></a>
Scheduler Sub Jobs</h3>
<p>The <code>JobHandlerContext</code> also contains a <code>scheduler</code> member which can be used to schedule jobs using the same scheduler that was used for the job. This allows jobs to call other jobs and wait for them to end.</p>
<h2><a class="anchor" id="autotoc_md967"></a>
Available Schedulers</h2>
<p>The Core Angular DevKit library provides 2 implementations for the <code>Scheduler</code> interface:</p>
<h2><a class="anchor" id="autotoc_md968"></a>
SimpleJobRegistry</h2>
<p>Available in the jobs namespace. A registry that accept job registration, and can also schedule jobs.</p>
<div class="fragment"><div class="line">import { jobs } from &#39;@angular-devkit/core&#39;;</div>
<div class="line"> </div>
<div class="line">const add = jobs.createJobHandler&lt;number[], number&gt;(</div>
<div class="line">  argument =&gt; argument.reduce((total, curr) =&gt; total + curr, 0),</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">// Register the job in a SimpleJobRegistry. Different registries have different API.</div>
<div class="line">const registry = new jobs.SimpleJobRegistry();</div>
<div class="line">const scheduler = new SimpleJobScheduler(registry);</div>
<div class="line"> </div>
<div class="line">registry.register(add, {</div>
<div class="line">  name: &#39;add&#39;,</div>
<div class="line">  argument: { type: &#39;array&#39;, items: { type: &#39;number&#39; } },</div>
<div class="line">  output: { type: &#39;number&#39; },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">scheduler.schedule(&#39;add&#39;, [1, 2, 3, 4]);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md969"></a>
NodeModuleJobRegistry</h2>
<p>Available through <code>@angular-devkit/core/node</code>.</p>
<p>A scheduler that loads jobs using their node package names. These jobs need to use the <code>createJobHandler()</code> helper and report their argument/input/output schemas that way.</p>
<div class="fragment"><div class="line">declare const registry: NodeModuleJobRegistry;</div>
<div class="line">const scheduler = new SimpleJobScheduler(registry);</div>
<div class="line"> </div>
<div class="line">scheduler.schedule(&#39;some-node-package#someExport&#39;, &#39;input&#39;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md970"></a>
Gotchas</h1>
<ol type="1">
<li>Deadlocking Dependencies <br  />
 It is impossible to add dependencies to an already running job, but it is entirely possible to get locked between jobs. Be aware of your own dependencies.</li>
</ol>
<ol type="1">
<li>Using <code>job.promise</code> <br  />
 <code>job.promise</code> waits for the job to ends. Don't rely on it unless you know the job is not watching and running for a long time. If you aren't sure, use <code>job.output.pipe(first()).toPromise()</code> instead which will return the first next output, regardless of whether the job watches and rerun or not.</li>
</ol>
<h1><a class="anchor" id="autotoc_md971"></a>
FAQ</h1>
<ol type="1">
<li>Laziness <br  />
 A job is lazy until executed, but its messages will be replayed when resubscribed.</li>
</ol>
<ol type="1">
<li><p class="startli">Serialize Strategy vs Dependencies <br  />
 Strategies are functions that transform the execution of a job, and can be used when declaring the job, or registering it. Dependencies, on the other hand, are listed when scheduling a job to order jobs during scheduling.</p>
<p class="startli">A job has no control over the way it's scheduled, and its dependencies. It can, however, declare that it shouldn't run at the same time as itself. Alternatively, a user could schedule a job twice and imply that the second run should wait for the first to finish. In practice, this would be equivalent to having the job be serialized, but the important detail is in <em>whom</em> is defining the rules; using the <code>serialize()</code> strategy, the job implementation is, while when using dependencies, the user is.</p>
<p class="startli">The user does not need to know how to job needs to synchronize with itself, and the job does not need to know how it synchronizes with other jobs that it doesn't know about. That's part of the strength of this system as every job can be developed in a vacuum, only caring about its contracts (argument, input and output) and its own synchronization. </p>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
