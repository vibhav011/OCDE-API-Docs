<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OCDE: protoduck &lt;a href=&quot;https://npm.im/protoduck&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/v/protoduck.svg&quot; alt=&quot;npm version&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://npm.im/protoduck&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/l/protoduck.svg&quot; alt=&quot;license&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://travis-ci.org/zkat/protoduck&quot;&gt;&lt;img src=&quot;https://img.shields.io/travis/zkat/protoduck.svg&quot; alt=&quot;Travis&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://ci.appveyor.com/project/zkat/protoduck&quot;&gt;&lt;img src=&quot;https://ci.appveyor.com/api/projects/status/github/zkat/protoduck?svg=true&quot; alt=&quot;AppVeyor&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://coveralls.io/github/zkat/protoduck?branch=latest&quot;&gt;&lt;img src=&quot;https://coveralls.io/repos/github/zkat/protoduck/badge.svg?branch=latest&quot; alt=&quot;Coverage Status&quot;/&gt;&lt;/a&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OCDE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_frontend_node_modules_protoduck__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">protoduck <a href="https://npm.im/protoduck"><img src="https://img.shields.io/npm/v/protoduck.svg" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="https://npm.im/protoduck"><img src="https://img.shields.io/npm/l/protoduck.svg" alt="license" style="pointer-events: none;" class="inline"/></a> <a href="https://travis-ci.org/zkat/protoduck"><img src="https://img.shields.io/travis/zkat/protoduck.svg" alt="Travis" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/zkat/protoduck"><img src="https://ci.appveyor.com/api/projects/status/github/zkat/protoduck?svg=true" alt="AppVeyor" class="inline"/></a> <a href="https://coveralls.io/github/zkat/protoduck?branch=latest"><img src="https://coveralls.io/repos/github/zkat/protoduck/badge.svg?branch=latest" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/zkat/protoduck"><code>protoduck</code></a> is a JavaScript library is a library for making groups of methods, called "protocols".</p>
<p>If you're familiar with the concept of <a href="https://en.wikipedia.org/wiki/Duck_typing">"duck typing"</a>, then it might make sense to think of protocols as things that explicitly define what methods you need in order to "clearly be a duck".</p>
<h1><a class="anchor" id="autotoc_md21493"></a>
Install</h1>
<p><code>$ npm install -S protoduck</code></p>
<h1><a class="anchor" id="autotoc_md21494"></a>
Table of Contents</h1>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#guide">Guide</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#defining-protocols">Defining protocols</a></li>
<li><a href="#protocol-impls">Implementations</a></li>
<li><a href="#multiple-dispatch">Multiple dispatch</a></li>
<li><a href="#constraints">Constraints</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#define"><code>define()</code></a></li>
<li><a href="#impl"><code>proto.impl()</code></a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md21495"></a>
Example</h2>
<div class="fragment"><div class="line">const protoduck = require(&#39;protoduck&#39;)</div>
<div class="line"> </div>
<div class="line">// Quackable is a protocol that defines three methods</div>
<div class="line">const Quackable = protoduck.define({</div>
<div class="line">  walk: [],</div>
<div class="line">  talk: [],</div>
<div class="line">  isADuck: [() =&gt; true] // default implementation -- it&#39;s optional!</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// `duck` must implement `Quackable` for this function to work. It doesn&#39;t</div>
<div class="line">// matter what type or class duck is, as long as it implements Quackable.</div>
<div class="line">function doStuffToDucks (duck) {</div>
<div class="line">  if (!duck.isADuck()) {</div>
<div class="line">    throw new Error(&#39;I want a duck!&#39;)</div>
<div class="line">  } else {</div>
<div class="line">    console.log(duck.walk())</div>
<div class="line">    console.log(duck.talk())</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ...In a different package:</div>
<div class="line">const ducks = require(&#39;./ducks&#39;)</div>
<div class="line"> </div>
<div class="line">class Duck () {}</div>
<div class="line"> </div>
<div class="line">// Implement the protocol on the Duck class.</div>
<div class="line">ducks.Quackable.impl(Duck, {</div>
<div class="line">  walk () { return &quot;*hobble hobble*&quot; }</div>
<div class="line">  talk () { return &quot;QUACK QUACK&quot; }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// main.js</div>
<div class="line">ducks.doStuffToDucks(new Duck()) // works!</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21496"></a>
Features</h2>
<ul>
<li>Verifies implementations in case methods are missing or wrong ones added</li>
<li>Helpful, informative error messages</li>
<li>Optional default method implementations</li>
<li>Fresh JavaScript Feelâ„¢ &ndash; methods work just like native methods when called</li>
<li>Methods can dispatch on arguments, not just <code>this</code> (<a href="https://npm.im/genfun">multimethods</a>)</li>
<li>Type constraints</li>
</ul>
<h2><a class="anchor" id="autotoc_md21497"></a>
Guide</h2>
<h3><a class="anchor" id="autotoc_md21498"></a>
Introduction</h3>
<p>Like most Object-oriented languages, JavaScript comes with its own way of defining methods: You simply add regular <code>function</code>s as properties to regular objects, and when you do <code>obj.method()</code>, it calls the right code! ES6/ES2015 further extended this by adding a <code>class</code> syntax that allowed this same system to work with more familiar syntax sugar: <code>class Foo { method() { ... } }</code>.</p>
<p>The point of "protocols" is to have a more explicit definitions of what methods "go together". That is, a protocol is a description of a type of object your code interacts with. If someone passes an object into your library, and it fits your defined protocol, the assumption is that the object will work just as well.</p>
<p>Duck typing is a common term for this sort of thing: If it walks like a duck, and it talks like a duck, then it may as well be a duck, as far as any of our code is concerned.</p>
<p>Many other languages have similar or identical concepts under different names: Java's interfaces, Haskell's typeclasses, Rust's traits. Elixir and Clojure both call them "protocols" as well.</p>
<p>One big advantage to using these protocols is that they let users define their own versions of some abstraction, without requiring the type to inherit from another &ndash; protocols are independent of inheritance, even though they're able to work together with it. If you've ever found yourself in some sort of inheritance mess, this is exactly the sort of thing you use to escape it.</p>
<h3><a class="anchor" id="autotoc_md21499"></a>
Defining Protocols</h3>
<p>The first step to using <code>protoduck</code> is to define a protocol. Protocol definitions look like this:</p>
<div class="fragment"><div class="line">// import the library first!</div>
<div class="line">const protoduck = require(&#39;protoduck&#39;)</div>
<div class="line"> </div>
<div class="line">// `Ducklike` is the name of our protocol. It defines what it means for</div>
<div class="line">// something to be &quot;like a duck&quot;, as far as our code is concerned.</div>
<div class="line">const Ducklike = protoduck.define([], {</div>
<div class="line">  walk: [], // This says that the protocol requires a &quot;walk&quot; method.</div>
<div class="line">  talk: [] // and ducks also need to talk</div>
<div class="line">  peck: [] // and they can even be pretty scary</div>
<div class="line">})</div>
</div><!-- fragment --><p>Protocols by themselves don't really <em>do</em> anything, they simply define what methods are included in the protocol, and thus what will need to be implemented.</p>
<h3><a class="anchor" id="autotoc_md21500"></a>
Protocol Impls</h3>
<p>The simplest type of definitions for protocols are as regular methods. In this style, protocols end up working exactly like normal JavaScript methods: they're added as properties of the target type/object, and we call them using the <code>foo.method()</code> syntax. <code>this</code> is accessible inside the methods, as usual.</p>
<p>Implementation syntax is very similar to protocol definitions, using <code>.impl</code>:</p>
<div class="fragment"><div class="line">class Dog {}</div>
<div class="line"> </div>
<div class="line">// Implementing `Ducklike` for `Dog`s</div>
<div class="line">Ducklike.impl(Dog, [], {</div>
<div class="line">  walk () { return &#39;*pads on all fours*&#39; }</div>
<div class="line">  talk () { return &#39;woof woof. I mean &quot;quack&quot; &gt;_&gt;&#39; }</div>
<div class="line">  peck (victim) { return &#39;Can I just bite &#39; + victim + &#39; instead?...&#39; }</div>
<div class="line">})</div>
</div><!-- fragment --><p>So now, our <code>Dog</code> class has two extra methods: <code>walk</code>, and <code>talk</code>, and we can just call them:</p>
<div class="fragment"><div class="line">const pupper = new Dog()</div>
<div class="line"> </div>
<div class="line">pupper.walk() // *pads on all fours*</div>
<div class="line">pupper.talk() // woof woof. I mean &quot;quack&quot; &gt;_&gt;</div>
<div class="line">pupper.peck(&#39;this string&#39;) // Can I just bite this string instead?...</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21501"></a>
Multiple Dispatch</h3>
<p>You may have noticed before that we have these <code>[]</code> in various places that don't seem to have any obvious purpose.</p>
<p>These arrays allow protocols to be implemented not just for a single value of <code>this</code>, but across <em>all arguments</em>. That is, you can have methods in these protocols that use both <code>this</code>, and the first argument (or any other arguments) in order to determine what code to actually execute.</p>
<p>This type of method is called a multimethod, and is one of the differences between protoduck and the default <code>class</code> syntax.</p>
<p>To use it: in the protocol <em>definitions</em>, you put matching strings in different spots where those empty arrays were, and when you <em>implement</em> the protocol, you give the definition the actual types/objects you want to implement it on, and it takes care of mapping types to the strings you defined, and making sure the right code is run:</p>
<div class="fragment"><div class="line">const Playful = protoduck.define([&#39;friend&#39;], {// &lt;---\</div>
<div class="line">  playWith: [&#39;friend&#39;] // &lt;------------ these correspond to each other</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">class Cat {}</div>
<div class="line">class Human {}</div>
<div class="line">class Dog {}</div>
<div class="line"> </div>
<div class="line">// The first protocol is for Cat/Human combination</div>
<div class="line">Playful.impl(Cat, [Human], {</div>
<div class="line">  playWith (human) {</div>
<div class="line">    return &#39;*headbutt* *purr* *cuddle* omg ilu, &#39; + human.name</div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// And we define it *again* for a different combination</div>
<div class="line">Playful.impl(Cat, [Dog], {</div>
<div class="line">  playWith (dog) {</div>
<div class="line">    return &#39;*scratches* *hisses* omg i h8 u, &#39; + dog.name</div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// depending on what you call it with, it runs different methods:</div>
<div class="line">const cat = new Cat()</div>
<div class="line">const human = new Human()</div>
<div class="line">const dog = new Dog()</div>
<div class="line"> </div>
<div class="line">cat.playWith(human) // *headbutt* *purr* *cuddle* omg ilu, Sam</div>
<div class="line">cat.playWith(dog) // *scratches* *hisses* omg i h8 u, Pupper</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21502"></a>
Constraints</h3>
<p>Sometimes, you want to have all the functionality of a certain protocol, but you want to add a few requirements or other bits an pieces. Usually, you would have to define the entire functionality of the "parent" protocol in your own protocol in order to pull this off. This isn't very DRY and thus prone to errors, missing or out-of-sync functionality, or other issues. You could also just tell users "hey, if you implement this, make sure to implement that", but there's no guarantee they'll know about it, or know which arguments map to what.</p>
<p>This is where constraints come in: You can define a protocol that expects anything that implements it to <em>also</em> implement one or more "parent" protocols.</p>
<div class="fragment"><div class="line">const Show = proto.define({</div>
<div class="line">  // This syntax allows default impls without using arrays.</div>
<div class="line">  toString () {</div>
<div class="line">    return Object.prototype.toString.call(this)</div>
<div class="line">  },</div>
<div class="line">  toJSON () {</div>
<div class="line">    return JSON.stringify(this)</div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const Log = proto.define({</div>
<div class="line">  log () { console.log(this.toString()) }</div>
<div class="line">}, {</div>
<div class="line">  where: Show()</div>
<div class="line">  // Also valid:</div>
<div class="line">  // [Show(&#39;this&#39;), Show(&#39;a&#39;)]</div>
<div class="line">  // [Show(&#39;this&#39;, [&#39;a&#39;, &#39;b&#39;])]</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// This fails with an error: must implement Show:</div>
<div class="line">Log.impl(MyThing)</div>
<div class="line"> </div>
<div class="line">// So derive Show first...</div>
<div class="line">Show.impl(MyThing)</div>
<div class="line">// And now it&#39;s ok!</div>
<div class="line">Log.impl(MyThing)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21503"></a>
API</h2>
<h3><a class="anchor" id="autotoc_md21504"></a>
&lt;a name="define"&gt;&lt;/a&gt; &lt;tt&gt;define(&lt;types&gt;?, &lt;spec&gt;, &lt;opts&gt;)&lt;/tt&gt;</h3>
<p>Defines a new protocol on across arguments of types defined by <code>&lt;types&gt;</code>, which will expect implementations for the functions specified in <code>&lt;spec&gt;</code>.</p>
<p>If <code>&lt;types&gt;</code> is missing, it will be treated the same as if it were an empty array.</p>
<p>The types in <code>&lt;spec&gt;</code> entries must map, by string name, to the type names specified in <code>&lt;types&gt;</code>, or be an empty array if <code>&lt;types&gt;</code> is omitted. The types in <code>&lt;spec&gt;</code> will then be used to map between method implementations for the individual functions, and the provided types in the impl.</p>
<p>Protocols can include an <code>opts</code> object as the last argument, with the following available options:</p>
<ul>
<li><code>opts.name</code> <code>{String}</code> - The name to use when referring to the protocol.</li>
<li><code>opts.where</code> <code>{Array[Constraint]|Constraint}</code> - Protocol constraints to use.</li>
<li><code>opts.metaobject</code> - Accepts an object implementing the <code>Protoduck</code> protocol, which can be used to alter protocol definition mechanisms in <code>protoduck</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md21505"></a>
Example</h4>
<div class="fragment"><div class="line">const Eq = protoduck.define([&#39;a&#39;], {</div>
<div class="line">  eq: [&#39;a&#39;]</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21506"></a>
&lt;a name="impl"&gt;&lt;/a&gt; &lt;tt&gt;proto.impl(&lt;target&gt;, &lt;types&gt;?, &lt;implementations&gt;?)&lt;/tt&gt;</h3>
<p>Adds a new implementation to the given protocol across <code>&lt;types&gt;</code>.</p>
<p><code>&lt;implementations&gt;</code> must be an object with functions matching the protocol's API. If given, the types in <code>&lt;types&gt;</code> will be mapped to their corresponding method arguments according to the original protocol definition.</p>
<p>If a protocol is derivable &ndash; that is, all its functions have default impls, then the <code>&lt;implementations&gt;</code> object can be omitted entirely, and the protocol will be automatically derived for the given <code>&lt;types&gt;</code></p>
<h4><a class="anchor" id="autotoc_md21507"></a>
Example</h4>
<div class="fragment"><div class="line">import protoduck from &#39;protoduck&#39;</div>
<div class="line"> </div>
<div class="line">// Singly-dispatched protocols</div>
<div class="line">const Show = protoduck.define({</div>
<div class="line">  show: []</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">class Foo {</div>
<div class="line">  constructor (name) {</div>
<div class="line">    this.name = name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Show.impl(Foo, {</div>
<div class="line">  show () { return `[object Foo(${this.name})]` }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const f = new Foo(&#39;alex&#39;)</div>
<div class="line">f.show() === &#39;[object Foo(alex)]&#39;</div>
</div><!-- fragment --><div class="fragment"><div class="line">import protoduck from &#39;protoduck&#39;</div>
<div class="line"> </div>
<div class="line">// Multi-dispatched protocols</div>
<div class="line">const Comparable = protoduck.define([&#39;target&#39;], {</div>
<div class="line">  compare: [&#39;target&#39;],</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">class Foo {}</div>
<div class="line">class Bar {}</div>
<div class="line">class Baz {}</div>
<div class="line"> </div>
<div class="line">Comparable.impl(Foo, [Bar], {</div>
<div class="line">  compare (bar) { return &#39;bars are ok&#39; }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">Comparable.impl(Foo, [Baz], {</div>
<div class="line">  compare (baz) { return &#39;but bazzes are better&#39; }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const foo = new Foo()</div>
<div class="line">const bar = new Bar()</div>
<div class="line">const baz = new Baz()</div>
<div class="line"> </div>
<div class="line">foo.compare(bar) // &#39;bars are ok&#39;</div>
<div class="line">foo.compare(baz) // &#39;but bazzes are better&#39;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
