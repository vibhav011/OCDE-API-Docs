<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OCDE: cacache &lt;a href=&quot;https://npm.im/cacache&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/v/cacache.svg&quot; alt=&quot;npm version&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://npm.im/cacache&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/l/cacache.svg&quot; alt=&quot;license&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://travis-ci.org/zkat/cacache&quot;&gt;&lt;img src=&quot;https://img.shields.io/travis/zkat/cacache.svg&quot; alt=&quot;Travis&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://ci.appveyor.com/project/zkat/cacache&quot;&gt;&lt;img src=&quot;https://ci.appveyor.com/api/projects/status/github/zkat/cacache?svg=true&quot; alt=&quot;AppVeyor&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://coveralls.io/github/zkat/cacache?branch=latest&quot;&gt;&lt;img src=&quot;https://coveralls.io/repos/github/zkat/cacache/badge.svg?branch=latest&quot; alt=&quot;Coverage Status&quot;/&gt;&lt;/a&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OCDE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_frontend_node_modules_webpack_node_modules_cacache__r_e_a_d_m_e_8es.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">cacache <a href="https://npm.im/cacache"><img src="https://img.shields.io/npm/v/cacache.svg" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="https://npm.im/cacache"><img src="https://img.shields.io/npm/l/cacache.svg" alt="license" style="pointer-events: none;" class="inline"/></a> <a href="https://travis-ci.org/zkat/cacache"><img src="https://img.shields.io/travis/zkat/cacache.svg" alt="Travis" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/zkat/cacache"><img src="https://ci.appveyor.com/api/projects/status/github/zkat/cacache?svg=true" alt="AppVeyor" class="inline"/></a> <a href="https://coveralls.io/github/zkat/cacache?branch=latest"><img src="https://coveralls.io/repos/github/zkat/cacache/badge.svg?branch=latest" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/zkat/cacache"><code>cacache</code></a> es una librería de Node.js para manejar caches locales en disco, con acceso tanto con claves únicas como direcciones de contenido (hashes/hacheos). Es súper rápida, excelente con el acceso concurrente, y jamás te dará datos incorrectos, aún si se corrompen o manipulan directamente los ficheros del cache.</p>
<p>El propósito original era reemplazar el caché local de <a href="https://npm.im/npm">npm</a>, pero se puede usar por su propia cuenta.</p>
<p><em>Traducciones: <a class="el" href="md__r_e_a_d_m_e.html">English</a></em></p>
<h1><a class="anchor" id="autotoc_md31569"></a>
Instalación</h1>
<p><code>$ npm install --save cacache</code></p>
<h1><a class="anchor" id="autotoc_md31570"></a>
Índice</h1>
<ul>
<li><a href="#ejemplo">Ejemplo</a></li>
<li><a href="#características">Características</a></li>
<li><a href="#cómo-contribuir">Cómo Contribuir</a></li>
<li><a href="#api">API</a><ul>
<li><a href="#localized-api">Usando el API en español</a></li>
<li>Leer<ul>
<li><a href="#ls"><code>ls</code></a></li>
<li><a href="#ls-stream"><code>ls.flujo</code></a></li>
<li><a href="#get-data"><code>saca</code></a></li>
<li><a href="#get-stream"><code>saca.flujo</code></a></li>
<li><a href="#get-info"><code>saca.info</code></a></li>
<li><a href="#get-hasContent"><code>saca.tieneDatos</code></a></li>
</ul>
</li>
<li>Escribir<ul>
<li><a href="#put-data"><code>mete</code></a></li>
<li><a href="#put-stream"><code>mete.flujo</code></a></li>
<li><a href="#put-options">opciones para <code>mete*</code></a></li>
<li><a href="#rm-all"><code>rm.todo</code></a></li>
<li><a href="#rm-entry"><code>rm.entrada</code></a></li>
<li><a href="#rm-content"><code>rm.datos</code></a></li>
</ul>
</li>
<li>Utilidades<ul>
<li><a href="#set-locale"><code>ponLenguaje</code></a></li>
<li><a href="#clear-memoized"><code>limpiaMemoizado</code></a></li>
<li><a href="#tmp-mkdir"><code>tmp.hazdir</code></a></li>
<li><a href="#with-tmp"><code>tmp.conTmp</code></a></li>
</ul>
</li>
<li>Integridad<ul>
<li><a href="#integrity">Subresource Integrity</a></li>
<li><a href="#verify"><code>verifica</code></a></li>
<li><a href="#verify-last-run"><code>verifica.ultimaVez</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md31571"></a>
Ejemplo</h2>
<div class="fragment"><div class="line">const cacache = require(&#39;cacache/es&#39;)</div>
<div class="line">const fs = require(&#39;fs&#39;)</div>
<div class="line"> </div>
<div class="line">const tarbol = &#39;/ruta/a/mi-tar.tgz&#39;</div>
<div class="line">const rutaCache = &#39;/tmp/my-toy-cache&#39;</div>
<div class="line">const clave = &#39;mi-clave-única-1234&#39;</div>
<div class="line"> </div>
<div class="line">// ¡Añádelo al caché! Usa `rutaCache` como raíz del caché.</div>
<div class="line">cacache.mete(rutaCache, clave, &#39;10293801983029384&#39;).then(integrity =&gt; {</div>
<div class="line">  console.log(`Saved content to ${rutaCache}.`)</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const destino = &#39;/tmp/mytar.tgz&#39;</div>
<div class="line"> </div>
<div class="line">// Copia el contenido del caché a otro fichero, pero esta vez con flujos.</div>
<div class="line">cacache.saca.flujo(</div>
<div class="line">  rutaCache, clave</div>
<div class="line">).pipe(</div>
<div class="line">  fs.createWriteStream(destino)</div>
<div class="line">).on(&#39;finish&#39;, () =&gt; {</div>
<div class="line">  console.log(&#39;extracción completada&#39;)</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// La misma cosa, pero accesando el contenido directamente, sin tocar el índice.</div>
<div class="line">cacache.saca.porHacheo(rutaCache, integridad).then(datos =&gt; {</div>
<div class="line">  fs.writeFile(destino, datos, err =&gt; {</div>
<div class="line">    console.log(&#39;datos del tarbol sacados basado en su sha512, y escrito a otro fichero&#39;)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31572"></a>
Características</h2>
<ul>
<li>Extracción por clave o por dirección de contenido (shasum, etc)</li>
<li>Usa el estándard de web, <a href="#integrity">Subresource Integrity</a></li>
<li>Compatible con multiples algoritmos - usa sha1, sha512, etc, en el mismo caché sin problema</li>
<li>Entradas con contenido idéntico comparten ficheros</li>
<li>Tolerancia de fallas (inmune a corrupción, ficheros parciales, carreras de proceso, etc)</li>
<li>Verificación completa de datos cuando (escribiendo y leyendo)</li>
<li>Concurrencia rápida, segura y "lockless"</li>
<li>Compatible con <code>stream</code>s (flujos)</li>
<li>Compatible con <code>Promise</code>s (promesas)</li>
<li>Bastante rápida &ndash; acceso, incluyendo verificación, en microsegundos</li>
<li>Almacenaje de metadatos arbitrarios</li>
<li>Colección de basura y verificación adicional fuera de banda</li>
<li>Cobertura rigurosa de pruebas</li>
<li>Probablente hay un "Bloom filter" por ahí en algún lado. Eso le mola a la gente, ¿Verdad? 🤔</li>
</ul>
<h2><a class="anchor" id="autotoc_md31573"></a>
Cómo Contribuir</h2>
<p>El equipo de cacache felizmente acepta contribuciones de código y otras maneras de participación. ¡Hay muchas formas diferentes de contribuir! La <a class="el" href="webdriver-js-extender_2_c_o_n_t_r_i_b_u_t_i_n_g_8md.html">Guía de Colaboradores</a> (en inglés) tiene toda la información que necesitas para cualquier tipo de contribución: todo desde cómo reportar errores hasta cómo someter parches con nuevas características. Con todo y eso, no se preocupe por si lo que haces está exáctamente correcto: no hay ningún problema en hacer preguntas si algo no está claro, o no lo encuentras.</p>
<p>El equipo de cacache tiene miembros hispanohablantes: es completamente aceptable crear <code>issues</code> y <code>pull requests</code> en español/castellano.</p>
<p>Todos los participantes en este proyecto deben obedecer el <a class="el" href="websocket-driver_2_c_o_d_e___o_f___c_o_n_d_u_c_t_8md.html">Código de Conducta</a> (en inglés), y en general actuar de forma amable y respetuosa mientras participan en esta comunidad.</p>
<p>Por favor refiérase al <a class="el" href="md_frontend_node_modules_webpack_node_modules_cacache__c_h_a_n_g_e_l_o_g.html">Historial de Cambios</a> (en inglés) para detalles sobre cambios importantes incluídos en cada versión.</p>
<p>Finalmente, cacache tiene un sistema de localización de lenguaje. Si te interesa añadir lenguajes o mejorar los que existen, mira en el directorio <code>./locales</code> para comenzar.</p>
<p>Happy hacking!</p>
<h2><a class="anchor" id="autotoc_md31574"></a>
API</h2>
<h3><a class="anchor" id="autotoc_md31575"></a>
&lt;a name="localized-api"&gt;&lt;/a&gt; Usando el API en español</h3>
<p>cacache incluye una traducción completa de su API al castellano, con las mismas características. Para usar el API como está documentado en este documento, usa &lsquo;require('cacache/es&rsquo;)`</p>
<p>cacache también tiene otros lenguajes: encuéntralos bajo <code>./locales</code>, y podrás usar el API en ese lenguaje con &lsquo;require('cacache/&lt;lenguaje&gt;&rsquo;)`</p>
<h3><a class="anchor" id="autotoc_md31576"></a>
&lt;a name="ls"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.ls(cache) -&gt; Promise&lt;Object&gt;&lt;/tt&gt;</h3>
<p>Enumera todas las entradas en el caché, dentro de un solo objeto. Cada entrada en el objeto tendrá como clave la clave única usada para el índice, el valor siendo un objeto de <a href="#get-info"><code>saca.info</code></a>.</p>
<h4><a class="anchor" id="autotoc_md31577"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.ls(rutaCache).then(console.log)</div>
<div class="line">// Salida</div>
<div class="line">{</div>
<div class="line">  &#39;my-thing&#39;: {</div>
<div class="line">    key: &#39;my-thing&#39;,</div>
<div class="line">    integrity: &#39;sha512-BaSe64/EnCoDED+HAsh==&#39;</div>
<div class="line">    path: &#39;.testcache/content/deadbeef&#39;, // unido con `rutaCache`</div>
<div class="line">    time: 12345698490,</div>
<div class="line">    size: 4023948,</div>
<div class="line">    metadata: {</div>
<div class="line">      name: &#39;blah&#39;,</div>
<div class="line">      version: &#39;1.2.3&#39;,</div>
<div class="line">      description: &#39;this was once a package but now it is my-thing&#39;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">  &#39;other-thing&#39;: {</div>
<div class="line">    key: &#39;other-thing&#39;,</div>
<div class="line">    integrity: &#39;sha1-ANothER+hasH=&#39;,</div>
<div class="line">    path: &#39;.testcache/content/bada55&#39;,</div>
<div class="line">    time: 11992309289,</div>
<div class="line">    size: 111112</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31578"></a>
&lt;a name="ls-stream"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.ls.flujo(cache) -&gt; Readable&lt;/tt&gt;</h3>
<p>Enumera todas las entradas en el caché, emitiendo un objeto de <a href="#get-info"><code>saca.info</code></a> por cada evento de <code>data</code> en el flujo.</p>
<h4><a class="anchor" id="autotoc_md31579"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.ls.flujo(rutaCache).on(&#39;data&#39;, console.log)</div>
<div class="line">// Salida</div>
<div class="line">{</div>
<div class="line">  key: &#39;my-thing&#39;,</div>
<div class="line">  integrity: &#39;sha512-BaSe64HaSh&#39;,</div>
<div class="line">  path: &#39;.testcache/content/deadbeef&#39;, // unido con `rutaCache`</div>
<div class="line">  time: 12345698490,</div>
<div class="line">  size: 13423,</div>
<div class="line">  metadata: {</div>
<div class="line">    name: &#39;blah&#39;,</div>
<div class="line">    version: &#39;1.2.3&#39;,</div>
<div class="line">    description: &#39;this was once a package but now it is my-thing&#39;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  key: &#39;other-thing&#39;,</div>
<div class="line">  integrity: &#39;whirlpool-WoWSoMuchSupport&#39;,</div>
<div class="line">  path: &#39;.testcache/content/bada55&#39;,</div>
<div class="line">  time: 11992309289,</div>
<div class="line">  size: 498023984029</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31580"></a>
&lt;a name="get-data"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.saca(cache, clave, [ops]) -&gt; Promise({data, metadata, integrity})&lt;/tt&gt;</h3>
<p>Devuelve un objeto con los datos, hacheo de integridad y metadatos identificados por la <code>clave</code>. La propiedad <code>data</code> de este objeto será una instancia de <code>Buffer</code> con los datos almacenados en el caché. to do with it! cacache just won't care.</p>
<p><code>integrity</code> es un <code>string</code> de <a href="#integrity">Subresource Integrity</a>. Dígase, un <code>string</code> que puede ser usado para verificar a la <code>data</code>, que tiene como formato <code>&lt;algoritmo&gt;-&lt;hacheo-integridad-base64&gt;</code>.</p>
<p>So no existe ninguna entrada identificada por <code>clave</code>, o se los datos almacenados localmente fallan verificación, el <code>Promise</code> fallará.</p>
<p>Una sub-función, <code>saca.porHacheo</code>, tiene casi el mismo comportamiento, excepto que busca entradas usando el hacheo de integridad, sin tocar el índice general. Esta versión <em>sólo</em> devuelve <code>data</code>, sin ningún objeto conteniéndola.</p>
<h4><a class="anchor" id="autotoc_md31581"></a>
Nota</h4>
<p>Esta función lee la entrada completa a la memoria antes de devolverla. Si estás almacenando datos Muy Grandes, es posible que <a href="#get-stream"><code>saca.flujo</code></a> sea una mejor solución.</p>
<h4><a class="anchor" id="autotoc_md31582"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">// Busca por clave</div>
<div class="line">cache.saca(rutaCache, &#39;my-thing&#39;).then(console.log)</div>
<div class="line">// Salida:</div>
<div class="line">{</div>
<div class="line">  metadata: {</div>
<div class="line">    thingName: &#39;my&#39;</div>
<div class="line">  },</div>
<div class="line">  integrity: &#39;sha512-BaSe64HaSh&#39;,</div>
<div class="line">  data: Buffer#&lt;deadbeef&gt;,</div>
<div class="line">  size: 9320</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Busca por hacheo</div>
<div class="line">cache.saca.porHacheo(rutaCache, &#39;sha512-BaSe64HaSh&#39;).then(console.log)</div>
<div class="line">// Salida:</div>
<div class="line">Buffer#&lt;deadbeef&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31583"></a>
&lt;a name="get-stream"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.saca.flujo(cache, clave, [ops]) -&gt; Readable&lt;/tt&gt;</h3>
<p>Devuelve un <a href="https://nodejs.org/api/stream.html#stream_readable_streams">Readable Stream</a> de los datos almacenados bajo <code>clave</code>.</p>
<p>So no existe ninguna entrada identificada por <code>clave</code>, o se los datos almacenados localmente fallan verificación, el <code>Promise</code> fallará.</p>
<p><code>metadata</code> y <code>integrity</code> serán emitidos como eventos antes de que el flujo cierre.</p>
<p>Una sub-función, <code>saca.flujo.porHacheo</code>, tiene casi el mismo comportamiento, excepto que busca entradas usando el hacheo de integridad, sin tocar el índice general. Esta versión no emite eventos de <code>metadata</code> o <code>integrity</code>.</p>
<h4><a class="anchor" id="autotoc_md31584"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">// Busca por clave</div>
<div class="line">cache.saca.flujo(</div>
<div class="line">  rutaCache, &#39;my-thing&#39;</div>
<div class="line">).on(&#39;metadata&#39;, metadata =&gt; {</div>
<div class="line">  console.log(&#39;metadata:&#39;, metadata)</div>
<div class="line">}).on(&#39;integrity&#39;, integrity =&gt; {</div>
<div class="line">  console.log(&#39;integrity:&#39;, integrity)</div>
<div class="line">}).pipe(</div>
<div class="line">  fs.createWriteStream(&#39;./x.tgz&#39;)</div>
<div class="line">)</div>
<div class="line">// Salidas:</div>
<div class="line">metadata: { ... }</div>
<div class="line">integrity: &#39;sha512-SoMeDIGest+64==&#39;</div>
<div class="line"> </div>
<div class="line">// Busca por hacheo</div>
<div class="line">cache.saca.flujo.porHacheo(</div>
<div class="line">  rutaCache, &#39;sha512-SoMeDIGest+64==&#39;</div>
<div class="line">).pipe(</div>
<div class="line">  fs.createWriteStream(&#39;./x.tgz&#39;)</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31585"></a>
&lt;a name="get-info"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.saca.info(cache, clave) -&gt; Promise&lt;/tt&gt;</h3>
<p>Busca la <code>clave</code> en el índice del caché, devolviendo información sobre la entrada si existe.</p>
<h4><a class="anchor" id="autotoc_md31586"></a>
Campos</h4>
<ul>
<li><code>key</code> - Clave de la entrada. Igual al argumento <code>clave</code>.</li>
<li><code>integrity</code> - <a href="#integrity">hacheo de Subresource Integrity</a> del contenido al que se refiere esta entrada.</li>
<li><code>path</code> - Dirección del fichero de datos almacenados, unida al argumento <code>cache</code>.</li>
<li><code>time</code> - Hora de creación de la entrada</li>
<li><code>metadata</code> - Metadatos asignados a esta entrada por el usuario</li>
</ul>
<h4><a class="anchor" id="autotoc_md31587"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.saca.info(rutaCache, &#39;my-thing&#39;).then(console.log)</div>
<div class="line"> </div>
<div class="line">// Salida</div>
<div class="line">{</div>
<div class="line">  key: &#39;my-thing&#39;,</div>
<div class="line">  integrity: &#39;sha256-MUSTVERIFY+ALL/THINGS==&#39;</div>
<div class="line">  path: &#39;.testcache/content/deadbeef&#39;,</div>
<div class="line">  time: 12345698490,</div>
<div class="line">  size: 849234,</div>
<div class="line">  metadata: {</div>
<div class="line">    name: &#39;blah&#39;,</div>
<div class="line">    version: &#39;1.2.3&#39;,</div>
<div class="line">    description: &#39;this was once a package but now it is my-thing&#39;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31588"></a>
&lt;a name="get-hasContent"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.saca.tieneDatos(cache, integrity) -&gt; Promise&lt;/tt&gt;</h3>
<p>Busca un <a href="#integrity">hacheo Subresource Integrity</a> en el caché. Si existe el contenido asociado con <code>integrity</code>, devuelve un objeto con dos campos: el hacheo <em>específico</em> que se usó para la búsqueda, <code>sri</code>, y el tamaño total del contenido, <code>size</code>. Si no existe ningún contenido asociado con <code>integrity</code>, devuelve <code>false</code>.</p>
<h4><a class="anchor" id="autotoc_md31589"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.saca.tieneDatos(rutaCache, &#39;sha256-MUSTVERIFY+ALL/THINGS==&#39;).then(console.log)</div>
<div class="line"> </div>
<div class="line">// Salida</div>
<div class="line">{</div>
<div class="line">  sri: {</div>
<div class="line">    source: &#39;sha256-MUSTVERIFY+ALL/THINGS==&#39;,</div>
<div class="line">    algorithm: &#39;sha256&#39;,</div>
<div class="line">    digest: &#39;MUSTVERIFY+ALL/THINGS==&#39;,</div>
<div class="line">    options: []</div>
<div class="line">  },</div>
<div class="line">  size: 9001</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">cacache.saca.tieneDatos(rutaCache, &#39;sha521-NOT+IN/CACHE==&#39;).then(console.log)</div>
<div class="line"> </div>
<div class="line">// Salida</div>
<div class="line">false</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31590"></a>
&lt;a name="put-data"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.mete(cache, clave, datos, [ops]) -&gt; Promise&lt;/tt&gt;</h3>
<p>Inserta <code>datos</code> en el caché. El <code>Promise</code> devuelto se resuelve con un hacheo (generado conforme a <a href="#optsalgorithms"><code>ops.algorithms</code></a>) después que la entrada haya sido escrita en completo.</p>
<h4><a class="anchor" id="autotoc_md31591"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">fetch(</div>
<div class="line">  &#39;https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz&#39;</div>
<div class="line">).then(datos =&gt; {</div>
<div class="line">  return cacache.mete(rutaCache, &#39;registry.npmjs.org|cacache@1.0.0&#39;, datos)</div>
<div class="line">}).then(integridad =&gt; {</div>
<div class="line">  console.log(&#39;el hacheo de integridad es&#39;, integridad)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31592"></a>
&lt;a name="put-stream"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.mete.flujo(cache, clave, [ops]) -&gt; Writable&lt;/tt&gt;</h3>
<p>Devuelve un <a href="https://nodejs.org/api/stream.html#stream_writable_streams">Writable Stream</a> que inserta al caché los datos escritos a él. Emite un evento <code>integrity</code> con el hacheo del contenido escrito, cuando completa.</p>
<h4><a class="anchor" id="autotoc_md31593"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">request.get(</div>
<div class="line">  &#39;https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz&#39;</div>
<div class="line">).pipe(</div>
<div class="line">  cacache.mete.flujo(</div>
<div class="line">    rutaCache, &#39;registry.npmjs.org|cacache@1.0.0&#39;</div>
<div class="line">  ).on(&#39;integrity&#39;, d =&gt; console.log(`integrity digest is ${d}`))</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31594"></a>
&lt;a name="put-options"&gt;&lt;/a&gt; &lt;tt&gt;&gt; opciones para cacache.mete&lt;/tt&gt;</h3>
<p>La funciones <code>cacache.mete</code> tienen un número de opciones en común.</p>
<h4><a class="anchor" id="autotoc_md31595"></a>
&lt;tt&gt;ops.metadata&lt;/tt&gt;</h4>
<p>Metadatos del usuario que se almacenarán con la entrada.</p>
<h4><a class="anchor" id="autotoc_md31596"></a>
&lt;tt&gt;ops.size&lt;/tt&gt;</h4>
<p>El tamaño declarado de los datos que se van a insertar. Si es proveído, cacache verificará que los datos escritos sean de ese tamaño, o si no, fallará con un error con código <code>EBADSIZE</code>.</p>
<h4><a class="anchor" id="autotoc_md31597"></a>
&lt;tt&gt;ops.integrity&lt;/tt&gt;</h4>
<p>El hacheo de integridad de los datos siendo escritos.</p>
<p>Si es proveído, y los datos escritos no le corresponden, la operación fallará con un error con código <code>EINTEGRITY</code>.</p>
<p><code>ops.algorithms</code> no tiene ningún efecto si esta opción está presente.</p>
<h4><a class="anchor" id="autotoc_md31598"></a>
&lt;tt&gt;ops.algorithms&lt;/tt&gt;</h4>
<p>Por Defecto: &lsquo;['sha512&rsquo;]`</p>
<p>Algoritmos que se deben usar cuando se calcule el hacheo de <a href="#integrity">subresource integrity</a> para los datos insertados. Puede usar cualquier algoritmo enumerado en <code>crypto.getHashes()</code>.</p>
<p>Por el momento, sólo se acepta un algoritmo (dígase, un array con exáctamente un valor). No tiene ningún efecto si <code>ops.integrity</code> también ha sido proveido.</p>
<h4><a class="anchor" id="autotoc_md31599"></a>
&lt;tt&gt;ops.uid&lt;/tt&gt;/&lt;tt&gt;ops.gid&lt;/tt&gt;</h4>
<p>Si están presentes, cacache hará todo lo posible para asegurarse que todos los ficheros creados en el proceso de sus operaciones en el caché usen esta combinación en particular.</p>
<h4><a class="anchor" id="autotoc_md31600"></a>
&lt;tt&gt;ops.memoize&lt;/tt&gt;</h4>
<p>Por Defecto: <code>null</code></p>
<p>Si es verdad, cacache tratará de memoizar los datos de la entrada en memoria. La próxima vez que el proceso corriente trate de accesar los datos o entrada, cacache buscará en memoria antes de buscar en disco.</p>
<p>Si <code>ops.memoize</code> es un objeto regular o un objeto como <code>Map</code> (es decir, un objeto con métodos <code>get()</code> y <code>set()</code>), este objeto en sí sera usado en vez del caché de memoria global. Esto permite tener lógica específica a tu aplicación encuanto al almacenaje en memoria de tus datos.</p>
<p>Si quieres asegurarte que los datos se lean del disco en vez de memoria, usa <code>memoize: false</code> cuando uses funciones de <code>cacache.saca</code>.</p>
<h3><a class="anchor" id="autotoc_md31601"></a>
&lt;a name="rm-all"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.rm.todo(cache) -&gt; Promise&lt;/tt&gt;</h3>
<p>Borra el caché completo, incluyendo ficheros temporeros, ficheros de datos, y el índice del caché.</p>
<h4><a class="anchor" id="autotoc_md31602"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.rm.todo(rutaCache).then(() =&gt; {</div>
<div class="line">  console.log(&#39;THE APOCALYPSE IS UPON US 😱&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31603"></a>
&lt;a name="rm-entry"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.rm.entrada(cache, clave) -&gt; Promise&lt;/tt&gt;</h3>
<p>Alias: <code>cacache.rm</code></p>
<p>Borra la entrada <code>clave</code> del índuce. El contenido asociado con esta entrada seguirá siendo accesible por hacheo usando <a href="#get-stream"><code>saca.flujo.porHacheo</code></a>.</p>
<p>Para borrar el contenido en sí, usa <a href="#rm-content"><code>rm.datos</code></a>. Si quieres hacer esto de manera más segura (pues ficheros de contenido pueden ser usados por multiples entradas), usa <a href="#verify"><code>verifica</code></a> para borrar huérfanos.</p>
<h4><a class="anchor" id="autotoc_md31604"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.rm.entrada(rutaCache, &#39;my-thing&#39;).then(() =&gt; {</div>
<div class="line">  console.log(&#39;I did not like it anyway&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31605"></a>
&lt;a name="rm-content"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.rm.datos(cache, integrity) -&gt; Promise&lt;/tt&gt;</h3>
<p>Borra el contenido identificado por <code>integrity</code>. Cualquier entrada que se refiera a este contenido quedarán huérfanas y se invalidarán si se tratan de accesar, al menos que contenido idéntico sea añadido bajo <code>integrity</code>.</p>
<h4><a class="anchor" id="autotoc_md31606"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.rm.datos(rutaCache, &#39;sha512-SoMeDIGest/IN+BaSE64==&#39;).then(() =&gt; {</div>
<div class="line">  console.log(&#39;los datos para `mi-cosa` se borraron&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31607"></a>
&lt;a name="set-locale"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.ponLenguaje(locale)&lt;/tt&gt;</h3>
<p>Configura el lenguaje usado para mensajes y errores de cacache. La lista de lenguajes disponibles está en el directorio <code>./locales</code> del proyecto.</p>
<p><em>Te interesa añadir más lenguajes? <a class="el" href="webdriver-js-extender_2_c_o_n_t_r_i_b_u_t_i_n_g_8md.html">Somete un PR</a>!</em></p>
<h3><a class="anchor" id="autotoc_md31608"></a>
&lt;a name="clear-memoized"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.limpiaMemoizado()&lt;/tt&gt;</h3>
<p>Completamente reinicializa el caché de memoria interno. Si estás usando tu propio objecto con <code>ops.memoize</code>, debes hacer esto de manera específica a él.</p>
<h3><a class="anchor" id="autotoc_md31609"></a>
&lt;a name="tmp-mkdir"&gt;&lt;/a&gt; &lt;tt&gt;&gt; tmp.hazdir(cache, ops) -&gt; Promise&lt;Path&gt;&lt;/tt&gt;</h3>
<p>Alias: <code>tmp.mkdir</code></p>
<p>Devuelve un directorio único dentro del directorio <code>tmp</code> del caché.</p>
<p>Una vez tengas el directorio, es responsabilidad tuya asegurarte que todos los ficheros escrito a él sean creados usando los permisos y <code>uid</code>/<code>gid</code> concordante con el caché. Si no, puedes pedirle a cacache que lo haga llamando a <a href="#tmp-fix"><code>cacache.tmp.fix()</code></a>. Esta función arreglará todos los permisos en el directorio tmp.</p>
<p>Si quieres que cacache limpie el directorio automáticamente cuando termines, usa <a href="#with-tpm"><code>cacache.tmp.conTmp()</code></a>.</p>
<h4><a class="anchor" id="autotoc_md31610"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.tmp.mkdir(cache).then(dir =&gt; {</div>
<div class="line">  fs.writeFile(path.join(dir, &#39;blablabla&#39;), Buffer#&lt;1234&gt;, ...)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31611"></a>
&lt;a name="with-tmp"&gt;&lt;/a&gt; &lt;tt&gt;&gt; tmp.conTmp(cache, ops, cb) -&gt; Promise&lt;/tt&gt;</h3>
<p>Crea un directorio temporero con <a href="#tmp-mkdir"><code>tmp.mkdir()</code></a> y ejecuta <code>cb</code> con él como primer argumento. El directorio creado será removido automáticamente cuando el valor devolvido por <code>cb()</code> se resuelva.</p>
<p>Las mismas advertencias aplican en cuanto a manejando permisos para los ficheros dentro del directorio.</p>
<h4><a class="anchor" id="autotoc_md31612"></a>
Ejemplo</h4>
<div class="fragment"><div class="line">cacache.tmp.conTmp(cache, dir =&gt; {</div>
<div class="line">  return fs.writeFileAsync(path.join(dir, &#39;blablabla&#39;), Buffer#&lt;1234&gt;, ...)</div>
<div class="line">}).then(() =&gt; {</div>
<div class="line">  // `dir` no longer exists</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31613"></a>
&lt;a name="integrity"&gt;&lt;/a&gt; Hacheos de Subresource Integrity</h3>
<p>cacache usa strings que siguen la especificación de <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity spec</a>.</p>
<p>Es decir, donde quiera cacache espera un argumento o opción <code>integrity</code>, ese string debería usar el formato <code>&lt;algoritmo&gt;-&lt;hacheo-base64&gt;</code>.</p>
<p>Una variación importante sobre los hacheos que cacache acepta es que acepta el nombre de cualquier algoritmo aceptado por el proceso de Node.js donde se usa. Puedes usar <code>crypto.getHashes()</code> para ver cuales están disponibles.</p>
<h4><a class="anchor" id="autotoc_md31614"></a>
Generando tus propios hacheos</h4>
<p>Si tienes un <code>shasum</code>, en general va a estar en formato de string hexadecimal (es decir, un <code>sha1</code> se vería como algo así: <code>5f5513f8822fdbe5145af33b64d8d970dcf95c6e</code>).</p>
<p>Para ser compatible con cacache, necesitas convertir esto a su equivalente en subresource integrity. Por ejemplo, el hacheo correspondiente al ejemplo anterior sería: <code>sha1-X1UT+IIv2+UUWvM7ZNjZcNz5XG4=</code>.</p>
<p>Puedes usar código así para generarlo por tu cuenta:</p>
<div class="fragment"><div class="line">const crypto = require(&#39;crypto&#39;)</div>
<div class="line">const algoritmo = &#39;sha512&#39;</div>
<div class="line">const datos = &#39;foobarbaz&#39;</div>
<div class="line"> </div>
<div class="line">const integrity = (</div>
<div class="line">  algorithm +</div>
<div class="line">  &#39;-&#39; +</div>
<div class="line">  crypto.createHash(algoritmo).update(datos).digest(&#39;base64&#39;)</div>
<div class="line">)</div>
</div><!-- fragment --><p>También puedes usar <a href="https://npm.im/ssri"><code>ssri</code></a> para deferir el trabajo a otra librería que garantiza que todo esté correcto, pues maneja probablemente todas las operaciones que tendrías que hacer con SRIs, incluyendo convirtiendo entre hexadecimal y el formato SRI.</p>
<h3><a class="anchor" id="autotoc_md31615"></a>
&lt;a name="verify"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.verifica(cache, ops) -&gt; Promise&lt;/tt&gt;</h3>
<p>Examina y arregla tu caché:</p>
<ul>
<li>Limpia entradas inválidas, huérfanas y corrompidas</li>
<li>Te deja filtrar cuales entradas retener, con tu propio filtro</li>
<li>Reclama cualquier ficheros de contenido sin referencias en el índice</li>
<li>Verifica integridad de todos los ficheros de contenido y remueve los malos</li>
<li>Arregla permisos del caché</li>
<li>Remieve el directorio <code>tmp</code> en el caché, y todo su contenido.</li>
</ul>
<p>Cuando termine, devuelve un objeto con varias estadísticas sobre el proceso de verificación, por ejemplo la cantidad de espacio de disco reclamado, el número de entradas válidas, número de entradas removidas, etc.</p>
<h4><a class="anchor" id="autotoc_md31616"></a>
Opciones</h4>
<ul>
<li><code>ops.uid</code> - uid para asignarle al caché y su contenido</li>
<li><code>ops.gid</code> - gid para asignarle al caché y su contenido</li>
<li><code>ops.filter</code> - recibe una entrada como argumento. Devuelve falso para removerla. Nota: es posible que esta función sea invocada con la misma entrada más de una vez.</li>
</ul>
<h4><a class="anchor" id="autotoc_md31617"></a>
Example</h4>
<div class="fragment"><div class="line">echo somegarbage &gt;&gt; $RUTACACHE/content/deadbeef</div>
</div><!-- fragment --><div class="fragment"><div class="line">cacache.verifica(rutaCache).then(stats =&gt; {</div>
<div class="line">  // deadbeef collected, because of invalid checksum.</div>
<div class="line">  console.log(&#39;cache is much nicer now! stats:&#39;, stats)</div>
<div class="line">})</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31618"></a>
&lt;a name="verify-last-run"&gt;&lt;/a&gt; &lt;tt&gt;&gt; cacache.verifica.ultimaVez(cache) -&gt; Promise&lt;/tt&gt;</h3>
<p>Alias: <code>últimaVez</code></p>
<p>Devuelve un <code>Date</code> que representa la última vez que <code>cacache.verifica</code> fue ejecutada en <code>cache</code>.</p>
<h4><a class="anchor" id="autotoc_md31619"></a>
Example</h4>
<div class="fragment"><div class="line">cacache.verifica(rutaCache).then(() =&gt; {</div>
<div class="line">  cacache.verifica.ultimaVez(rutaCache).then(última =&gt; {</div>
<div class="line">    console.log(&#39;La última vez que se usó cacache.verifica() fue &#39; + última)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
