<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OCDE: Tapable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OCDE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_frontend_node_modules_tapable__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tapable </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The tapable package expose many Hook classes, which can be used to create hooks for plugins.</p>
<div class="fragment"><div class="line">const {</div>
<div class="line">    SyncHook,</div>
<div class="line">    SyncBailHook,</div>
<div class="line">    SyncWaterfallHook,</div>
<div class="line">    SyncLoopHook,</div>
<div class="line">    AsyncParallelHook,</div>
<div class="line">    AsyncParallelBailHook,</div>
<div class="line">    AsyncSeriesHook,</div>
<div class="line">    AsyncSeriesBailHook,</div>
<div class="line">    AsyncSeriesWaterfallHook</div>
<div class="line"> } = require(&quot;tapable&quot;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29115"></a>
Installation</h1>
<div class="fragment"><div class="line">npm install --save tapable</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29116"></a>
Usage</h1>
<p>All Hook constructors take one optional argument, which is a list of argument names as strings.</p>
<div class="fragment"><div class="line">const hook = new SyncHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);</div>
</div><!-- fragment --><p>The best practice is to expose all hooks of a class in a <code>hooks</code> property:</p>
<div class="fragment"><div class="line">class Car {</div>
<div class="line">    constructor() {</div>
<div class="line">        this.hooks = {</div>
<div class="line">            accelerate: new SyncHook([&quot;newSpeed&quot;]),</div>
<div class="line">            brake: new SyncHook(),</div>
<div class="line">            calculateRoutes: new AsyncParallelHook([&quot;source&quot;, &quot;target&quot;, &quot;routesList&quot;])</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    /* ... */</div>
<div class="line">}</div>
</div><!-- fragment --><p>Other people can now use these hooks:</p>
<div class="fragment"><div class="line">const myCar = new Car();</div>
<div class="line"> </div>
<div class="line">// Use the tap method to add a consument</div>
<div class="line">myCar.hooks.brake.tap(&quot;WarningLampPlugin&quot;, () =&gt; warningLamp.on());</div>
</div><!-- fragment --><p>It's required to pass a name to identify the plugin/reason.</p>
<p>You may receive arguments:</p>
<div class="fragment"><div class="line">myCar.hooks.accelerate.tap(&quot;LoggerPlugin&quot;, newSpeed =&gt; console.log(`Accelerating to ${newSpeed}`));</div>
</div><!-- fragment --><p>For sync hooks, <code>tap</code> is the only valid method to add a plugin. Async hooks also support async plugins:</p>
<div class="fragment"><div class="line">myCar.hooks.calculateRoutes.tapPromise(&quot;GoogleMapsPlugin&quot;, (source, target, routesList) =&gt; {</div>
<div class="line">    // return a promise</div>
<div class="line">    return google.maps.findRoute(source, target).then(route =&gt; {</div>
<div class="line">        routesList.add(route);</div>
<div class="line">    });</div>
<div class="line">});</div>
<div class="line">myCar.hooks.calculateRoutes.tapAsync(&quot;BingMapsPlugin&quot;, (source, target, routesList, callback) =&gt; {</div>
<div class="line">    bing.findRoute(source, target, (err, route) =&gt; {</div>
<div class="line">        if(err) return callback(err);</div>
<div class="line">        routesList.add(route);</div>
<div class="line">        // call the callback</div>
<div class="line">        callback();</div>
<div class="line">    });</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// You can still use sync plugins</div>
<div class="line">myCar.hooks.calculateRoutes.tap(&quot;CachedRoutesPlugin&quot;, (source, target, routesList) =&gt; {</div>
<div class="line">    const cachedRoute = cache.get(source, target);</div>
<div class="line">    if(cachedRoute)</div>
<div class="line">        routesList.add(cachedRoute);</div>
<div class="line">})</div>
</div><!-- fragment --><p>The class declaring these hooks need to call them:</p>
<div class="fragment"><div class="line">class Car {</div>
<div class="line">    /* ... */</div>
<div class="line"> </div>
<div class="line">    setSpeed(newSpeed) {</div>
<div class="line">        this.hooks.accelerate.call(newSpeed);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    useNavigationSystemPromise(source, target) {</div>
<div class="line">        const routesList = new List();</div>
<div class="line">        return this.hooks.calculateRoutes.promise(source, target, routesList).then(() =&gt; {</div>
<div class="line">            return routesList.getRoutes();</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    useNavigationSystemAsync(source, target, callback) {</div>
<div class="line">        const routesList = new List();</div>
<div class="line">        this.hooks.calculateRoutes.callAsync(source, target, routesList, err =&gt; {</div>
<div class="line">            if(err) return callback(err);</div>
<div class="line">            callback(null, routesList.getRoutes());</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:</p><ul>
<li>The number of registered plugins (none, one, many)</li>
<li>The kind of registered plugins (sync, async, promise)</li>
<li>The used call method (sync, async, promise)</li>
<li>The number of arguments</li>
<li>Whether interception is used</li>
</ul>
<p>This ensures fastest possible execution.</p>
<h1><a class="anchor" id="autotoc_md29117"></a>
Hook types</h1>
<p>Each hook can be tapped with one or several functions. How they are executed depends on the hook type:</p>
<ul>
<li>Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.</li>
<li><b>Waterfall</b>. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.</li>
<li><b>Bail</b>. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.</li>
<li><b>Loop</b>. TODO</li>
</ul>
<p>Additionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:</p>
<ul>
<li><b>Sync</b>. A sync hook can only be tapped with synchronous functions (using <code>myHook.tap()</code>).</li>
<li><b>AsyncSeries</b>. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using <code>myHook.tap()</code>, <code>myHook.tapAsync()</code> and <code>myHook.tapPromise()</code>). They call each async method in a row.</li>
<li><b>AsyncParallel</b>. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using <code>myHook.tap()</code>, <code>myHook.tapAsync()</code> and <code>myHook.tapPromise()</code>). However, they run each async method in parallel.</li>
</ul>
<p>The hook type is reflected in its class name. E.g., <code>AsyncSeriesWaterfallHook</code> allows asynchronous functions and runs them in series, passing each function’s return value into the next function.</p>
<h1><a class="anchor" id="autotoc_md29118"></a>
Interception</h1>
<p>All Hooks offer an additional interception API:</p>
<div class="fragment"><div class="line">myCar.hooks.calculateRoutes.intercept({</div>
<div class="line">    call: (source, target, routesList) =&gt; {</div>
<div class="line">        console.log(&quot;Starting to calculate routes&quot;);</div>
<div class="line">    },</div>
<div class="line">    register: (tapInfo) =&gt; {</div>
<div class="line">        // tapInfo = { type: &quot;promise&quot;, name: &quot;GoogleMapsPlugin&quot;, fn: ... }</div>
<div class="line">        console.log(`${tapInfo.name} is doing its job`);</div>
<div class="line">        return tapInfo; // may return a new tapInfo object</div>
<div class="line">    }</div>
<div class="line">})</div>
</div><!-- fragment --><p><b>call</b>: <code>(...args) =&gt; void</code> Adding <code>call</code> to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.</p>
<p><b>tap</b>: <code>(tap: Tap) =&gt; void</code> Adding <code>tap</code> to your interceptor will trigger when a plugin taps into a hook. Provided is the <code>Tap</code> object. <code>Tap</code> object can't be changed.</p>
<p><b>loop</b>: <code>(...args) =&gt; void</code> Adding <code>loop</code> to your interceptor will trigger for each loop of a looping hook.</p>
<p><b>register</b>: <code>(tap: Tap) =&gt; Tap | undefined</code> Adding <code>register</code> to your interceptor will trigger for each added <code>Tap</code> and allows to modify it.</p>
<h1><a class="anchor" id="autotoc_md29119"></a>
Context</h1>
<p>Plugins and interceptors can opt-in to access an optional <code>context</code> object, which can be used to pass arbitrary values to subsequent plugins and interceptors.</p>
<div class="fragment"><div class="line">myCar.hooks.accelerate.intercept({</div>
<div class="line">    context: true,</div>
<div class="line">    tap: (context, tapInfo) =&gt; {</div>
<div class="line">        // tapInfo = { type: &quot;sync&quot;, name: &quot;NoisePlugin&quot;, fn: ... }</div>
<div class="line">        console.log(`${tapInfo.name} is doing it&#39;s job`);</div>
<div class="line"> </div>
<div class="line">        // `context` starts as an empty object if at least one plugin uses `context: true`.</div>
<div class="line">        // If no plugins use `context: true`, then `context` is undefined.</div>
<div class="line">        if (context) {</div>
<div class="line">            // Arbitrary properties can be added to `context`, which plugins can then access.</div>
<div class="line">            context.hasMuffler = true;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">myCar.hooks.accelerate.tap({</div>
<div class="line">    name: &quot;NoisePlugin&quot;,</div>
<div class="line">    context: true</div>
<div class="line">}, (context, newSpeed) =&gt; {</div>
<div class="line">    if (context &amp;&amp; context.hasMuffler) {</div>
<div class="line">        console.log(&quot;Silence...&quot;);</div>
<div class="line">    } else {</div>
<div class="line">        console.log(&quot;Vroom!&quot;);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29120"></a>
HookMap</h1>
<p>A HookMap is a helper class for a Map with Hooks</p>
<div class="fragment"><div class="line">const keyedHook = new HookMap(key =&gt; new SyncHook([&quot;arg&quot;]))</div>
</div><!-- fragment --><div class="fragment"><div class="line">keyedHook.tap(&quot;some-key&quot;, &quot;MyPlugin&quot;, (arg) =&gt; { /* ... */ });</div>
<div class="line">keyedHook.tapAsync(&quot;some-key&quot;, &quot;MyPlugin&quot;, (arg, callback) =&gt; { /* ... */ });</div>
<div class="line">keyedHook.tapPromise(&quot;some-key&quot;, &quot;MyPlugin&quot;, (arg) =&gt; { /* ... */ });</div>
</div><!-- fragment --><div class="fragment"><div class="line">const hook = keyedHook.get(&quot;some-key&quot;);</div>
<div class="line">if(hook !== undefined) {</div>
<div class="line">    hook.callAsync(&quot;arg&quot;, err =&gt; { /* ... */ });</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29121"></a>
Hook/HookMap interface</h1>
<p>Public:</p>
<div class="fragment"><div class="line">interface Hook {</div>
<div class="line">    tap: (name: string | Tap, fn: (context?, ...args) =&gt; Result) =&gt; void,</div>
<div class="line">    tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) =&gt; void) =&gt; void) =&gt; void,</div>
<div class="line">    tapPromise: (name: string | Tap, fn: (context?, ...args) =&gt; Promise&lt;Result&gt;) =&gt; void,</div>
<div class="line">    intercept: (interceptor: HookInterceptor) =&gt; void</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface HookInterceptor {</div>
<div class="line">    call: (context?, ...args) =&gt; void,</div>
<div class="line">    loop: (context?, ...args) =&gt; void,</div>
<div class="line">    tap: (context?, tap: Tap) =&gt; void,</div>
<div class="line">    register: (tap: Tap) =&gt; Tap,</div>
<div class="line">    context: boolean</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface HookMap {</div>
<div class="line">    for: (key: any) =&gt; Hook,</div>
<div class="line">    tap: (key: any, name: string | Tap, fn: (context?, ...args) =&gt; Result) =&gt; void,</div>
<div class="line">    tapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) =&gt; void) =&gt; void) =&gt; void,</div>
<div class="line">    tapPromise: (key: any, name: string | Tap, fn: (context?, ...args) =&gt; Promise&lt;Result&gt;) =&gt; void,</div>
<div class="line">    intercept: (interceptor: HookMapInterceptor) =&gt; void</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface HookMapInterceptor {</div>
<div class="line">    factory: (key: any, hook: Hook) =&gt; Hook</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Tap {</div>
<div class="line">    name: string,</div>
<div class="line">    type: string</div>
<div class="line">    fn: Function,</div>
<div class="line">    stage: number,</div>
<div class="line">    context: boolean</div>
<div class="line">}</div>
</div><!-- fragment --><p>Protected (only for the class containing the hook):</p>
<div class="fragment"><div class="line">interface Hook {</div>
<div class="line">    isUsed: () =&gt; boolean,</div>
<div class="line">    call: (...args) =&gt; Result,</div>
<div class="line">    promise: (...args) =&gt; Promise&lt;Result&gt;,</div>
<div class="line">    callAsync: (...args, callback: (err, result: Result) =&gt; void) =&gt; void,</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface HookMap {</div>
<div class="line">    get: (key: any) =&gt; Hook | undefined,</div>
<div class="line">    for: (key: any) =&gt; Hook</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md29122"></a>
MultiHook</h1>
<p>A helper Hook-like class to redirect taps to multiple other hooks:</p>
<div class="fragment"><div class="line">const { MultiHook } = require(&quot;tapable&quot;);</div>
<div class="line"> </div>
<div class="line">this.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
