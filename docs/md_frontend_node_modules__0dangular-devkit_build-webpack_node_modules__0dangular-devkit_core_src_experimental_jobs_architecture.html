<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OCDE: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OCDE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_frontend_node_modules__0dangular-devkit_build-webpack_node_modules__0dangular-devkit_core_src_experimental_jobs_architecture.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Jobs is a high-order API that adds inputs, runtime type checking, sequencing, and other functionality on top of RxJS' <code>Observable</code>s.</p>
<h1><a class="anchor" id="autotoc_md944"></a>
Background</h1>
<p>An <code>Observable</code> (at a higher level) is a function that receives a <code>Subscriber</code>, and outputs multiple values, and finishes once it calls the <code>Subscriber.prototype.complete()</code> method (in JavaScript):</p>
<div class="fragment"><div class="line">const output1To10EverySecond = function (subscriber) {</div>
<div class="line">  let t = 0;</div>
<div class="line">  const i = setInterval(() =&gt; {</div>
<div class="line">    t++;</div>
<div class="line">    subscriber.next(t);</div>
<div class="line">    if (t === 10) {</div>
<div class="line">      subscriber.complete(t);</div>
<div class="line">    }</div>
<div class="line">  }, 1000);</div>
<div class="line">  return () =&gt; clearInterval(i);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const stream$ = new Observable(output1To10EverySecond);</div>
<div class="line">// Start the function, and output 1 to 100, once per line.</div>
<div class="line">stream$.subscribe(x =&gt; console.log(x));</div>
</div><!-- fragment --><p>This, of course, can be typed in TypeScript, but those types are not enforced at runtime.</p>
<h1><a class="anchor" id="autotoc_md945"></a>
Glossary</h1>
<ul>
<li><code>job handler</code>. The function that implements the job's logic.</li>
<li><code>raw input</code>. The input observable sending messages to the job. These messages are of type <code>JobInboundMessage</code>.</li>
<li><code>raw output</code>. The output observer returned from the <code>job handler</code>. Messages on this observable are of type <code>JobOutboundMessage</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md946"></a>
Description</h1>
<p>A <code>JobHandler</code>, similar to observables, is a function that receives an argument and a context, and returns an <code>Observable</code> of messages, which can include outputs that are typed at runtime (using a Json Schema):</p>
<div class="fragment"><div class="line">const output1ToXEverySecond = function (x, context) {</div>
<div class="line">  return new Observable(subscriber =&gt; {</div>
<div class="line">    let t = 0;</div>
<div class="line"> </div>
<div class="line">    // Notify our users that the actual work is started.</div>
<div class="line">    subscriber.next({ kind: JobOutboundMessageKind.Start });</div>
<div class="line">    const i = setInterval(() =&gt; {</div>
<div class="line">      t++;</div>
<div class="line">      subscriber.next({ kind: JobOutboundMessageKind.Output, value: t });</div>
<div class="line">      if (t === x) {</div>
<div class="line">        subscriber.next({ kind: JobOutboundMessageKind.End });</div>
<div class="line">        subscriber.complete();</div>
<div class="line">      }</div>
<div class="line">    }, 1000);</div>
<div class="line"> </div>
<div class="line">    return () =&gt; {</div>
<div class="line">      clearInterval(i);</div>
<div class="line">    };</div>
<div class="line">  })</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// For now, jobs can not be called without a registry and scheduler.</div>
<div class="line">const registry = new SimpleJobRegistry();</div>
<div class="line">registry.register(&#39;output-from-1-to-x&#39;, output1ToXEverySecond, {</div>
<div class="line">  argument: { type: &#39;number&#39; },</div>
<div class="line">  output: { type: &#39;number&#39; },</div>
<div class="line">});</div>
<div class="line">const scheduler = new SimpleScheduler(registry);</div>
<div class="line"> </div>
<div class="line">// Need to keep the same name that the registry would understand.</div>
<div class="line">// Count from 1 to 10.</div>
<div class="line">const job = scheduler.schedule(&#39;output-from-1-to-x&#39;, 10);</div>
<div class="line"> </div>
<div class="line">// A Job&lt;&gt; instance has more members, but we only want the output values here.</div>
<div class="line">job.output.subscribe(x =&gt; console.log(x));</div>
</div><!-- fragment --><p>This seems like a lot of boilerplate in comparison, but there are a few advantages;</p>
<ol type="1">
<li>lifecycle. Jobs can tell when they start doing work and when work is done.</li>
</ol>
<ol type="1">
<li>everything is typed, even at runtime.</li>
</ol>
<ol type="1">
<li>the context also contains an input Observable that receives typed input messages, including input values, and stop requests.</li>
</ol>
<ol type="1">
<li>jobs can also schedule other jobs and wait for them, even if they don't know if a job is implemented in the system.</li>
</ol>
<h2><a class="anchor" id="autotoc_md947"></a>
Diagram</h2>
<p>A simpler way to think about jobs in contrast to observables is that job are closer to a Unix process. It has an argument (command line flags), receive inputs (STDIN and interrupt signals), and output values (STDOUT) as well as diagnostic (STDERR). They can be plugged one into another (piping), and can be transformed, synchronized and scheduled (fork, exec, cron).</p>
<div class="fragment"><div class="line">- given A the type of the argument</div>
<div class="line">- given I the type of the input</div>
<div class="line">- given O the type of the output</div>
<div class="line"> </div>
<div class="line">                              ,______________________   </div>
<div class="line">    JobInboundMessage&lt;I&gt; --&gt; | handler(argument: A) |  --&gt; JobOutboundMessage&lt;O&gt;</div>
<div class="line">                                                            - JobOutboundMessageKind.Output</div>
<div class="line">                                                            - ...</div>
</div><!-- fragment --><p><code>JobInboundMessage</code> includes:</p>
<ol type="1">
<li><code>JobInboundMessageKind.Ping</code>. A simple message that should be answered with <code>JobOutboundMessageKind.Pong</code> when the job is responsive. The <code>id</code> field of the message should be used when returning <code>Pong</code>.</li>
</ol>
<ol type="1">
<li><code>JobInboundMessageKind.Stop</code>. The job should be stopped. This is used when cancelling/unsubscribing from the <code>output</code> (or by calling <code>stop()</code>). Any inputs or outputs after this message will be ignored.</li>
</ol>
<ol type="1">
<li><code>JobInboundMessageKind.Input</code> is used when sending inputs to a job. These correspond to the <code>next</code> methods of an <code>Observer</code> and are reported to the job through its <code>context.input</code> Observable. There is no way to communicate an error to the job.</li>
</ol>
<p><code>JobOutboundMessage</code> includes:</p>
<ol type="1">
<li><code>JobOutboundMessageKind.Ready</code>. The <code>Job&lt;&gt;</code> was created, its dependencies are done, and the library is validating Argument and calling the internal job code.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Start</code>. The job code itself should send that message when started. <code>createJobHandler()</code> will do it automatically.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.End</code>. The job has ended. This is done by the job itself and should always be sent when completed. The scheduler will listen to this message to set the state and unblock dependent jobs. <code>createJobHandler()</code> automatically send this message.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Pong</code>. The job should answer a <code>JobInboundMessageKind.Ping</code> message with this. Automatically done by <code>createJobHandler()</code>.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.Output</code>. An <code>Output</code> has been generated by the job.</li>
</ol>
<ol type="1">
<li><code>JobOutboundMessageKind.ChannelMessage</code>, <code>JobOutboundMessageKind.ChannelError</code> and <code>JobOutboundMessageKind.ChannelComplete</code> are used for output channels. These correspond to the <code>next</code>, <code>error</code> and <code>complete</code> methods of an <code>Observer</code> and are available to the callee through the <code>job.channels</code> map of Observable.</li>
</ol>
<p>Utilities should have some filtering and dispatching to separate observables, as a convenience for the user. An example of this would be the <code>Job.prototype.output</code> observable which only contains the value contained by messages of type <code>JobOutboundMessageKind.Output</code>.</p>
<h1><a class="anchor" id="autotoc_md948"></a>
Higher Order Jobs</h1>
<p>Because jobs are expected to be pure functions, they can be composed or transformed to create more complex behaviour, similar to how RxJS operators can transform observables.</p>
<div class="fragment"><div class="line">// Runs a job on the hour, every hour, regardless of how long the job takes.</div>
<div class="line">// This creates a job function that can be registered by itself.</div>
<div class="line">function scheduleJobOnTheHour(jobFunction) {</div>
<div class="line">  return function(argument, context) {</div>
<div class="line">    return new Observable(observer =&gt; {</div>
<div class="line">      let timeout = 0;</div>
<div class="line">   </div>
<div class="line">      function _timeoutToNextHour() {</div>
<div class="line">        // Just wait until the next hour.</div>
<div class="line">        const t = new Date();</div>
<div class="line">        const secondsToNextHour = 3600 - t.getSeconds() - t.getMinutes() * 60;</div>
<div class="line">        timeout = setTimeout(_scheduleJobAndWaitAnHour, secondsToNextHour);</div>
<div class="line">      }</div>
<div class="line">   </div>
<div class="line">      function _scheduleJobAndWaitAnHour() {</div>
<div class="line">        jobFunction(argument, context).subscribe(</div>
<div class="line">          message =&gt; observer.next(message),</div>
<div class="line">          error =&gt; observer.error(error),</div>
<div class="line">          // Do not forward completion, but use it to schedule the next job run.</div>
<div class="line">          () =&gt; {</div>
<div class="line">            _timeoutToNextHour();</div>
<div class="line">          },</div>
<div class="line">        );</div>
<div class="line">      }</div>
<div class="line">   </div>
<div class="line">      // Kick off by waiting for next hour.</div>
<div class="line">      _timeoutToNextHour();</div>
<div class="line">   </div>
<div class="line">      return () =&gt; clearTimeout(timeout);</div>
<div class="line">    });</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another way to compose jobs is to schedule jobs based on their name, from other jobs.</p>
<div class="fragment"><div class="line">// Runs a job on the hour, every hour, regardless of how long the job takes.</div>
<div class="line">// This creates a high order job by getting a job name and an argument, and scheduling the job</div>
<div class="line">// every hour.</div>
<div class="line">function scheduleJobOnTheHour(job, context) {</div>
<div class="line">  const { name, argument } = job;  // Destructure our input.</div>
<div class="line"> </div>
<div class="line">  return new Observable(observer =&gt; {</div>
<div class="line">    let timeout = 0;</div>
<div class="line"> </div>
<div class="line">    function _timeoutToNextHour() {</div>
<div class="line">      // Just wait until the next hour.</div>
<div class="line">      const t = new Date();</div>
<div class="line">      const secondsToNextHour = 3600 - t.getSeconds() - t.getMinutes() * 60;</div>
<div class="line">      timeout = setTimeout(_scheduleJobAndWaitAnHour, secondsToNextHour);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    function _scheduleJobAndWaitAnHour() {</div>
<div class="line">      const subJob = context.scheduler.schedule(name, argument);</div>
<div class="line">      // We do not forward the input to the sub-job but that would be a valid example as well.</div>
<div class="line">      subJob.outboundBus.subscribe(</div>
<div class="line">        message =&gt; observer.next(message),</div>
<div class="line">        error =&gt; observer.error(error),</div>
<div class="line">        // Do not forward completion, but use it to schedule the next job run.</div>
<div class="line">        () =&gt; {</div>
<div class="line">          _timeoutToNextHour();</div>
<div class="line">        },</div>
<div class="line">      );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Kick off by waiting for next hour.</div>
<div class="line">    _timeoutToNextHour();</div>
<div class="line"> </div>
<div class="line">    return () =&gt; clearTimeout(timeout);</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const registry = new SimpleJobRegistry();</div>
<div class="line">registry.register(&#39;schedule-job-on-the-hour&#39;, scheduleJobOnTheHour, {</div>
<div class="line">  argument: {</div>
<div class="line">    properties: {</div>
<div class="line">      name: { type: &#39;string&#39; },</div>
<div class="line">      argument: { type: true },</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Implementation left to the reader.</div>
<div class="line">registry.register(&#39;copy-files-from-a-to-b&#39;, require(&#39;some-package/copy-job&#39;));</div>
<div class="line"> </div>
<div class="line">const scheduler = new SimpleScheduler(registry);</div>
<div class="line"> </div>
<div class="line">// A rudimentary backup system.</div>
<div class="line">const job = scheduler.schedule(&#39;schedule-job-on-the-hour&#39;, {</div>
<div class="line">  name: &#39;copy-files-from-a-to-b&#39;,</div>
<div class="line">  argument: {</div>
<div class="line">    from: &#39;/some-directory/to/backup&#39;,</div>
<div class="line">    to: &#39;/volumes/usb-key&#39;,</div>
<div class="line">  },</div>
<div class="line">});</div>
<div class="line">job.output.subscribe(x =&gt; console.log(x));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md949"></a>
Limitations</h1>
<p>Jobs input, output and argument must be serializable to JSONs. This is a big limitation in usage, but comes with the benefit that jobs can be serialized and called across memory boundaries. An example would be an operator that takes a module path and run the job from that path in a separate process. Or even a separate server, using HTTP calls.</p>
<p>Another limitation is that the boilerplate is complex. Manually managing start/end life cycle, and other messages such as ping/pong, etc. is tedious and requires a lot of code. A good way to keep this limitation under control is to provide helpers to create <code>JobHandler</code>s which manage those messages for the developer. A simple handler could be to get a <code>Promise</code> and return the output of that promise automatically. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
